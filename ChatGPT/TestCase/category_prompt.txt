All test cases must fall under one or more of the predefined behavior categories listed below.  
These categories define the structure, timing logic, complexity, and constraints of the test command to be generated.

âš ï¸ When a category is specified, you must generate a single Korean natural language command that fits that categoryâ€™s constraints exactly.  
Do not infer or improvise beyond the stated category rules.

ğŸ“š Category Definitions  
Each test case falls under one of the following 16 categories.  
Generate your test command strictly based on the intended logic and complexity of the specified category:

[Category 0: Device]  
- This category is designed to test **all functional capabilities** of a device, including both method calls and value reads.  
- The goal is to verify that each method can be executed and each attribute can be accessed successfully.  
- If the test case involves calling a method, the command must trigger that method directly with explicit parameters if needed.  
- If the test case involves reading an attribute, the value must be interpreted using **predefined conditions** and spoken via TTS.  
- Since TTS devices only support fixed strings, the test must map the value into one of several **clearly specified output sentences**.  
- Do not output raw values or dynamic strings.  
- Instead, define conditional logic like:  
  â€œIf the value is X or more, say A. If less, say B.â€  
- No loops, state tracking, or event-based triggers are allowed.  
- Do not use or test devices tagged as Timer or Clock.
- Do not generate any further complex commands.

Examples:  
- â€œì—ì–´ì»¨ì„ ì¼œ ì¤˜.â€  
- â€œTVì˜ ìŒëŸ‰ì„ 12ë¡œ ë§ì¶° ì¤˜.â€  
- â€œë¡œë´‡ì²­ì†Œê¸°ë¥¼ â€˜ìë™â€™ ëª¨ë“œë¡œ ì„¤ì •í•´ ì¤˜.â€  
- â€œí˜„ì¬ ì»¤íŠ¼ ìƒíƒœê°€ â€˜ì—´ë¦¼â€™ì´ë©´ â€˜ì»¤íŠ¼ì´ ì—´ë ¤ ìˆìŠµë‹ˆë‹¤.â€™, â€˜ë‹«í˜â€™ì´ë©´ â€˜ì»¤íŠ¼ì´ ë‹«í˜€ ìˆìŠµë‹ˆë‹¤.â€™ë¼ê³  ë§í•´ ì¤˜.â€  
- â€œì˜¨ë„ê°€ 25ë„ ì´ìƒì´ë©´ â€˜ì˜¨ë„ê°€ 25ë„ ì´ìƒì…ë‹ˆë‹¤.â€™, 25ë„ ë¯¸ë§Œì´ë©´ â€˜ì˜¨ë„ê°€ 25ë„ ë¯¸ë§Œì…ë‹ˆë‹¤.â€™ë¼ê³  ë§í•´ ì¤˜.â€  

[Category 1: Instantaneous Type 1]  
- This category represents a one-time, immediate action that executes as soon as the command is issued.  
- The behavior must be simple and atomic, completing immediately after execution.  
- You may use a basic `if` condition based on the current state of a device.  
- You may also include direct setting actions such as setting a mode, temperature, or volume.  
- Each command must result in only one immediate action, with no repetition, memory, or waiting.  
- Do not use loops, wait until triggers, or `Tags("Clock").clock_delay(...)`.  
- Do not use persistent variables or `period`.  
- Do not generate test cases that require the use of tags.
- This category is suitable for setting or toggling a single device based on a simple condition or command.

Examples:  
- â€œì¡°ëª…ì´ êº¼ì ¸ ìˆê³ , ì˜¨ë„ê°€ 33ë„ ì´ìƒì´ë©´ ì¡°ëª…ì„ ì¼œ ì¤˜.â€  
- â€œê³µê¸°ì²­ì •ê¸°ë¥¼ ì¼œ ì¤˜. ì¼œê³  ë³´ë‹ˆ ê³µê¸°ì²­ì •ê¸°ê°€ ìë™ ëª¨ë“œë©´ ë‹¤ì‹œ êº¼ ì¤˜â€  
- â€œì—ì–´ì»¨ ì˜¨ë„ë¥¼ 25ë„ë¡œ ë§ì¶° ì¤˜. ê·¸ í›„ ì¡°ëª… ë°ê¸°ë¥¼ 80ìœ¼ë¡œ ì„¤ì •í•´ ì¤˜â€  
- â€œë¬¸ì´ ì—´ë ¤ ìˆìœ¼ë©´ ë‹«ê³ , ë‹«í˜€ ìˆìœ¼ë©´ ì—´ì–´ ì¤˜â€  
- â€œTVì˜ ë³¼ë¥¨ì„ 10ìœ¼ë¡œ ì„¤ì •í•´ ì¤˜. ë§Œì•½ TVê°€ êº¼ì ¸ ìˆìœ¼ë©´ ì¼œ ì¤˜â€



[Category 2: Instantaneous Type 2]  
- This category represents a one-time action that executes immediately but may include a more complex structure than Type 1.  
- The command must complete instantly, without any repetition or delay.  
- It may contain **multiple conditions** and **multiple actions**, as long as everything happens at once.  
- Conditions can be nested or combined using `if`, `elif`, or `else`.  
- Multiple devices may be controlled in a single command if all actions are performed immediately.  
- Do not use loops, wait until triggers, `Tags("Clock").clock_delay(...)`, persistent variables, or `period`.  
- Do not generate test cases that require the use of tags.
- This category is often used for scenario-based multi-device responses with complex decision logic.

Examples:  
- â€œì¡°ëª…ì´ êº¼ì ¸ ìˆê³  ë¸”ë¼ì¸ë“œê°€ ì—´ë ¤ ìˆìœ¼ë©° ì—ì–´ì»¨ ì „ì›ì´ êº¼ì ¸ ìˆìœ¼ë©´, ì¡°ëª…ì„ ì¼œê³  ë¸”ë¼ì¸ë“œë¥¼ ë‹«ê³  ì—ì–´ì»¨ì„ ìë™ ëª¨ë“œë¡œ ì„¤ì •í•´ ì¤˜.â€  
- â€œì°½ë¬¸ì´ ì—´ë ¤ ìˆê³  ìŠµë„ê°€ 60% ì´ìƒì´ë©´, ì œìŠµê¸°ë¥¼ ì¼œê³  ì•ŒëŒì˜ ìŒëŸ‰ì„ â€˜highâ€™ë¡œ ì„¤ì •í•œ ë‹¤ìŒ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œTVê°€ ì¼œì ¸ ìˆê±°ë‚˜ ìŠ¤í”¼ì»¤ê°€ ì¬ìƒ ì¤‘ì´ë©´, TVì™€ ìŠ¤í”¼ì»¤ ì „ì›ì„ êº¼ ì£¼ê³  ë¸”ë¼ì¸ë“œê°€ ì—´ë ¤ ìˆìœ¼ë©´ ë‹«ì•„ ì¤˜.â€  
- â€œì—ì–´ì»¨ ì „ì›ì´ êº¼ì ¸ ìˆê³  í˜„ì¬ ì˜¨ë„ê°€ 28ë„ ì´ìƒì´ë©´, ì—ì–´ì»¨ì„ â€˜coolâ€™ ëª¨ë“œë¡œ ì„¤ì •í•˜ê³  ì¡°ëª…ì´ ì¼œì ¸ ìˆìœ¼ë©´ ë°ê¸°ë¥¼ 30ìœ¼ë¡œ ì¡°ì ˆí•´ ì¤˜.â€  
- â€œë¬¸ì´ ë‹«í˜€ ìˆê³  ì›€ì§ì„ì´ ê°ì§€ë˜ì§€ ì•Šìœ¼ë©´, ëª¨ë“  ì¡°ëª…ê³¼ ì„ í’ê¸°ë¥¼ êº¼ ì£¼ê³  ì»¤íŠ¼ì´ ì—´ë ¤ ìˆìœ¼ë©´ ë‹«ì•„ ì¤˜.â€




[Category 3: Periodic]  
- This category represents the repeated execution of a simple action at clearly defined time intervals.  
- The repetition must be triggered by either a cron schedule, a fixed interval (`period`), or both.  
- The time condition must be explicitly stated using natural expressions (e.g., â€œë§¤ì¼â€, â€œ5ì´ˆë§ˆë‹¤â€, â€œë§¤ì£¼ ì›”ìš”ì¼ 9ì‹œë¶€í„° 10ì‹œê¹Œì§€â€).  
- Four types of periodic timing must be supported in this category:

  1. Use `cron` with `period = -1`: Executes once at a scheduled time.  
     - Example: â€œì§€ê¸ˆ ì•ŒëŒì„ í•œ ë²ˆ ìš¸ë ¤ ì¤˜.â€  

  2. Use `cron` with `period = 0`: Executes once **each time** the cron condition is met.  
     - Example: â€œë§¤ì¼ ì˜¤ì „ 9ì‹œ 0ë¶„ê³¼ 20ë¶„ì— ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  

  3. Use `period > 0` without cron: Executes repeatedly at a fixed interval.  
     - Example: â€œ30ì´ˆë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  

  4. Use both `cron` and `period > 0`: Executes repeatedly at a fixed interval during a scheduled window.  
     - Example: â€œë§¤ì£¼ ì›”ìš”ì¼ ì˜¤ì „ 9ì‹œë¶€í„° 10ì‹œ ì‚¬ì´ì— 30ì´ˆë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€

- The action must be simple and self-contained.  
- Do not use `wait until`, persistent variables, or `Tags("Clock").clock_delay(...)`.  
- Do not include any memory, counters, or state tracking logic.  
- Do not generate test cases that require the use of tags.
- This category is strictly time-driven and uses `period` to control the internal loop repetition.

Examples:  
- â€œì§€ê¸ˆ ì•ŒëŒì„ í•œ ë²ˆ ìš¸ë ¤ ì¤˜.â€  
- â€œë§¤ì¼ ì˜¤ì „ 9ì‹œ 0ë¶„ê³¼ 20ë¶„ì— ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œ30ì´ˆë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œë§¤ì£¼ ì›”ìš”ì¼ ì˜¤ì „ 9ì‹œë¶€í„° 10ì‹œ ì‚¬ì´ì— 30ì´ˆë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œë§¤ì¼ ë°¤ 11ì‹œë¶€í„° ìì •ê¹Œì§€ 10ì´ˆë§ˆë‹¤ ì¡°ëª…ì„ êº¼ ì¤˜.â€

[Category 4: Delay-based]
- This category represents actions that occur after a fixed time delay.
- You must use Tags("Clock").clock_delay(...) to implement the delay logic.
- The delay must be specified in seconds, minutes, or hours using explicit numeric expressions (e.g., â€œ5ì´ˆ í›„â€, â€œ10ì´ˆ ë’¤â€, â€œ3ë¶„ ëŒ€ê¸° í›„â€).
- The condition may be based on the current state of a device (state-based) or may simply be omitted for unconditional delays.
- No repetition, memory, or event tracking is allowed. The action must occur once after the delay, and then terminate.
- Do not use period, cron, wait_until, or persistent variables.
- Do not generate test cases that require the use of tags other than Tags("Clock").clock_delay(...).
- The use of Tags("Clock").clock_delay(...) must be the only form of timing control.

Examples:
- â€œì°½ë¬¸ì´ ì—´ë ¤ ìˆìœ¼ë©´ 10ì´ˆ í›„ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€
- â€œ3ì´ˆë§ˆë‹¤ ì¡°ëª…ì„ ê¹œë¹¡ì´ëŠ” ê²ƒì„ ì´ 3ë²ˆ ë°˜ë³µí•´ ì¤˜.â€
- â€œ10ì´ˆ í›„ ì„ í’ê¸°ë¥¼ êº¼ ì¤˜.â€
- â€œì¡°ëª…ì´ êº¼ì ¸ ìˆìœ¼ë©´ 5ì´ˆ ë’¤ ë¸”ë¼ì¸ë“œë¥¼ ë‚´ë¦¬ê³ , 5ì´ˆ ë” ê¸°ë‹¤ë¦° ë’¤ ë¸”ë¼ì¸ë“œë¥¼ ì˜¬ë ¤ ì¤˜.â€
- â€œTVê°€ ì¼œì ¸ ìˆìœ¼ë©´ 2ì´ˆ ëŒ€ê¸° í›„ ê·¸ ë•Œë„ TVê°€ ì¼œì ¸ ìˆìœ¼ë©´ ìŠ¤í”¼ì»¤ë¥¼ êº¼ ì¤˜.â€

[Category 5: Wait (Trigger-based)]  
- This category represents one-time actions triggered by a **state change or event**, not time.  
- The trigger must be implemented using `wait until`, which suspends execution until the specified condition becomes true.  
- The action must be executed **only once** when the condition is met for the **first time**, regardless of how many times the condition occurs again.  
- Conditions using "~ë©´" should execute **only once when the event first occurs**, not repeatedly when the condition is met multiple times.  
- Do not use `period`, persistent variables, or `Tags("Clock").clock_delay(...)`.  
- Do not add any timing-based scheduling (e.g., cron). 
- Do not generate test cases that require the use of tags. 
- After the action is executed, the command must terminate immediately.

Examples:  
- â€œì°½ë¬¸ì´ ì—´ë¦¬ë©´ ì•ŒëŒì„ í•œ ë²ˆ ìš¸ë ¤ ì¤˜.â€  
- â€œì‚¬ëŒì´ ê°ì§€ë˜ë©´ ì¡°ëª…ì„ ì¼œ ì¤˜.â€  
- â€œë¬¸ì´ ë‹«íˆë©´ ë¸”ë¼ì¸ë“œë¥¼ ë‚´ë ¤ ì¤˜.â€  
- â€œTVê°€ êº¼ì§€ë©´ ìŠ¤í”¼ì»¤ë¥¼ êº¼ ì¤˜.â€  
- â€œë¬¸ì´ ì—´ë¦¬ë©´ â€˜ë¬¸ì´ ì—´ë ¸ìŠµë‹ˆë‹¤â€™ë¼ê³  ë§í•´ ì¤˜.â€

[Category 6: Break]
- This category represents scenarios where an action is repeated at fixed intervals (period > 0), but must stop immediately when a specific condition becomes true.
- The action is repeated using either real-time polling (period = 100) or longer intervals (e.g., every 10 seconds, 5 seconds).
- A break condition is mandatory. As soon as this condition is satisfied, the behavior must terminate using break.
- The system must check the condition on every period cycle, and terminate only when the condition is newly satisfied.
- Do not generate test cases that require the use of tags. 
- wait until, cron, persistent variables and Tags("Clock").clock_delay(...) are not allowed.

Examples:
- â€œ10ì´ˆë§ˆë‹¤ ì „ë“±ì„ í† ê¸€í•´ ì¤˜. ë‹¨, ê·¸ë•Œë§ˆë‹¤ í™•ì¸í•˜ì—¬ ë¬¸ì´ ì—´ë ¤ ìˆìœ¼ë©´ í–‰ë™ì„ ë©ˆì¶° ì¤˜.â€
- â€œì‹¤ì‹œê°„ìœ¼ë¡œ ë¬¸ì´ ì—´ë ¤ ìˆëŠ”ì§€ í™•ì¸í•´ì„œ ì—´ë ¤ ìˆë‹¤ë©´ ì—ì–´ì»¨ì„ ì¼œê³ , ë‹«í˜€ ìˆë‹¤ë©´ ì—ì–´ì»¨ì„ êº¼ ì¤˜. ë‹¨, ìŠµë„ê°€ 70%ë¥¼ ë„˜ìœ¼ë©´ ëª¨ë“  ë™ì‘ì„ ì¤‘ë‹¨í•´ ì¤˜.â€
- â€œ5ì´ˆë§ˆë‹¤ ì°½ë¬¸ì„ ì—´ì–´ ì¤˜. ë‹¨, ë¸”ë¼ì¸ë“œê°€ ë‹«í˜€ ìˆìœ¼ë©´ ë°˜ë³µì„ ë©ˆì¶° ì¤˜.â€
- â€œ5ì´ˆë§ˆë‹¤ ì˜¨ì‹¤ ë¸”ë¼ì¸ë“œë¥¼ í•œ ë‹¨ê³„ì”© ë‚´ë ¤ ì¤˜. ë” ì´ìƒ ëª» ë‚´ë¦´ ë•Œê¹Œì§€.â€


[Category 7: Realtime]  
- This category represents actions that must be executed **every time** a specific condition becomes true.  
- The condition is expected to occur repeatedly over time, and each new occurrence must trigger the action again.  
- You must explicitly state that the condition should be checked in real time such as, "ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•´ì„œ", "3ì´ˆë§ˆë‹¤ ì²´í¬í•´ì„œ", "ë§¤ì´ˆ ê²€ì‚¬í•´ì„œ", etc.
- Do not use `cron` or `Tags("Clock").clock_delay(...)`.  
- Do not generate test cases that require the use of tags. 
- This category is used to respond in real time to repeated events or transitions.

Examples:  
- â€œì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•´ì„œ ë¬¸ì´ ì—´ë ¤ ìˆì„ ë•Œë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œì‚¬ëŒì´ ê°ì§€ë  ë•Œë§ˆë‹¤ ì¡°ëª…ì„ ì¼œ ì¤˜. ì‹¤ì‹œê°„ í™•ì¸ìœ¼ë¡œ.â€  
- â€œë§¤ì´ˆ í™•ì¸í•´ì„œ ì¡°ëª…ì´ ì¼œì§ˆ ë•Œë§ˆë‹¤ ë¸”ë¼ì¸ë“œë¥¼ ì—´ì–´ ì¤˜.â€  
- â€œ3ì´ˆë§ˆë‹¤ í™•ì¸í•´ì„œ ë¬¸ì´ ì—´ë¦´ ë•Œë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜. ë‹¨, **ìµœì´ˆë¡œ ì—´ë ¸ì„ ë•ŒëŠ” ì œì™¸í•˜ê³ ** ë‘ ë²ˆì§¸ë¶€í„° ìš¸ë ¤ ì¤˜.â€  
- â€œTVê°€ ì¼œì§ˆ ë•Œë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜. ì‹¤ì‹œê°„ ê²€ì‚¬ë¡œ. ë‹¨, ì•ŒëŒì€ **3ì´ˆ ì´ìƒ êº¼ì ¸ ìˆì—ˆë˜ ê²½ìš°ì—ë§Œ** ë‹¤ì‹œ ìš¸ë ¤ ì¤˜.â€  


[Category 8: Period + Wait]  
- This category represents scenarios where a condition must be detected **once**, and after that, an action is repeated at a fixed interval.  
- Use `wait until` to detect the **first occurrence** of a state or event.  
- After detection, the system must begin repeating an action using `period > 0`.  
- The condition is never checked again.  
- The repetition continues until the next scheduled cron event (if any), or until the scenario ends.  
- Do not use persistent state tracking to re-evaluate the trigger condition.  
- Do not generate test cases that require the use of tags. 
- This category is often used when a temporary or reactive state must trigger repeated behavior for a short duration.

Examples:  
- â€œì°½ë¬¸ì´ ì—´ë¦¬ë©´ 2ì´ˆë§ˆë‹¤ ë¸”ë¼ì¸ë“œë¥¼ í•œ ë‹¨ê³„ì”© ë‚´ë ¤ ì¤˜.â€  
- â€œì›€ì§ì„ì´ ê°ì§€ë˜ë©´ 1ì´ˆë§ˆë‹¤ TV ë³¼ë¥¨ì„ 2ì”© ë†’ì—¬ì„œ ìµœëŒ€ 10ê¹Œì§€ ì˜¬ë ¤ ì¤˜.â€  
- â€œì—ì–´ì»¨ì´ êº¼ì§€ë©´ 5ì´ˆë§ˆë‹¤ â€˜ì—ì–´ì»¨ì„ ì¼œ ì£¼ì„¸ìš”â€™ë¼ëŠ” ë¬¸ì¥ì„ 3ë²ˆ ë§í•´ ì¤˜.â€  
- â€œë¬¸ì´ ë‹«íˆë©´ 10ì´ˆë§ˆë‹¤ ì¡°ëª…ì˜ ë°ê¸°ë¥¼ 10ì”© ë‚®ì¶°ì„œ ì™„ì „íˆ êº¼ì§ˆ ë•Œê¹Œì§€ ë°˜ë³µí•´ ì¤˜.â€  
- â€œì¡°ëª…ì´ ì¼œì§€ë©´ 2ì´ˆë§ˆë‹¤ ì°½ë¬¸ê³¼ ì»¤íŠ¼ì„ ë²ˆê°ˆì•„ ì—´ê³  ë‹«ì•„ ì¤˜.â€  
- â€œTVê°€ ì¼œì§€ë©´ 3ì´ˆë§ˆë‹¤ ìŠ¤í”¼ì»¤ì™€ ì¡°ëª…ì„ ê»ë‹¤ ì¼°ë‹¤ ë°˜ë³µí•´ ì¤˜.â€  



[Category 9: Loop Logic Type 1]  
- This category coordinates simple timed or repeated behavior using `cron`, `period`, or `wait until`.  
- The command may involve combining multiple timing mechanisms to create simple loops or schedules.  
- The behavior must remain simple and not require any persistent variables, counters, or stored memory.  
- Do not use `Tags("Clock").clock_delay(...)` or any explicit delay-based waiting.  
- Each loop or timing event must be handled naturally through time triggers only.  
- Do not generate test cases that require the use of tags. 
- This category is used to create basic flow control where time alone determines the actions.

Examples:  
- â€œë§¤ì¼ ì˜¤ì „ 9ì‹œì— ë¶ˆì„ ì¼œ ì¤˜.â€  
- â€œë§¤ì£¼ ì›”ìš”ì¼ ì•„ì¹¨ 8ì‹œì— ì°½ë¬¸ì„ ì—´ì–´ ì¤˜.â€  
- â€œ5ì´ˆë§ˆë‹¤ ì¡°ëª…ì„ ê¹œë¹¡ì—¬ ì¤˜.â€  
- â€œì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•˜ì—¬ ë¬¸ì´ ì—´ë¦´ ë•Œë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•˜ì—¬ ì¡°ëª…ì´ ì¼œì§€ë©´ ë¸”ë¼ì¸ë“œë¥¼ ë‹«ì•„ ì¤˜.â€  
- â€œë§¤ì¼ ë°¤ 11ì‹œë§ˆë‹¤ ì°½ë¬¸ì„ ë‹«ê³  ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€

[Category 10: Loop Logic Type 2]  
- This category builds on Loop Logic Type 1 by allowing the use of persistent variables.  
- You must track states, counters, timers, or other values across multiple cycles.  
- Persistent memory is required to perform history-dependent decisions or comparisons.  
- The command must involve saving and using previous information, not just evaluating the current state.  
- You may use `cron`, `period`, and `wait until` freely.  
- You must not use `Tags("Clock").clock_delay(...)` for intentional delays between actions.  
- Do not generate test cases that require the use of tags. 
- This category is used for scenarios where the system needs to remember, compare, or accumulate past events across time.

Examples:  
- â€œë¶ˆì´ 5ë²ˆ ì¼œì§€ë©´ ì„ í’ê¸°ë¥¼ êº¼ ì¤˜.â€  
- â€œ10ì´ˆë§ˆë‹¤ ë¬¸ì´ ì—´ë ¤ ìˆëŠ”ì§€ í™•ì¸í•´ì„œ, ì´ì „ê³¼ ë‹¤ë¥´ë©´ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œë¬¸ì´ ì—´ë ¸ë‹¤ ë‹«íŒ íšŸìˆ˜ê°€ 3ë²ˆì´ ë˜ë©´ ì»¤íŠ¼ì„ ë‹«ì•„ ì¤˜.â€  
- â€œì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•˜ì—¬ ë¬¸ì´ ë‘ ë²ˆ ì—´ë ¸ë‹¤ ë‹«í˜”ì„ ë•Œ, ì²« ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ì‹œê°„ë³´ë‹¤ ë‘ ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ì‹œê°„ì´ ê¸¸ë©´ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•˜ì—¬ ë¬¸ì´ ë‘ ë²ˆ ì—´ë ¸ë‹¤ ë‹«í˜”ì„ ë•Œ, ë‘ ë²ˆì§¸ë¡œ ì—´ë ¸ë˜ ì‹œê°„ì´ ë” ê¸¸ë©´ ì•ŒëŒì„ ìš¸ë¦¬ê³ , ì´í›„ ìƒˆë¡œìš´ ë‘ ë²ˆì˜ ì´ë²¤íŠ¸ë¥¼ ë‹¤ì‹œ ì¶”ì í•´ ì´ ê³¼ì •ì„ ë°˜ë³µí•´ ì¤˜.â€  
- â€œì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•˜ì—¬ ë¬¸ì´ ë‘ ë²ˆ ì—´ë ¸ë‹¤ ë‹«í˜”ì„ ë•Œ, ì²« ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ê¸°ê°„ë³´ë‹¤ ë‘ ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ê¸°ê°„ì´ ë” ê¸¸ë©´ ê·¸ ë•Œë¶€í„° 10ì´ˆ, 20ì´ˆ, 30ì´ˆ...ë¡œ ì ì  ëŠ˜ì–´ë‚˜ëŠ” ì£¼ê¸°ë¡œ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜. ë°˜ëŒ€ë¼ë©´ ê°€ë§Œíˆ ìˆê³ . ë‹¨, ë‹¤ì‹œ í•œ ë²ˆ ë¬¸ì´ ì—´ë¦¬ëŠ” ì‹œì ì—ì„œ ì´ˆê¸°í™”í•˜ì—¬ ê·¸ ì‚¬ê±´ì„ ì²« ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ìœ¼ë¡œ ê°„ì£¼í•˜ë©´ì„œ 10ì´ˆ ì£¼ê¸°ë¡œ ì•ŒëŒ ìš¸ë¦¬ë˜ ê²ƒì„ ì§€ì†í•´ì¤˜. ë‹¨, í•œ ë²ˆ ë” ë¬¸ì´ ì—´ë¦¬ë©´ ê·¸ ì‚¬ê±´ì„ ë‹¤ì‹œ ë‘ ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ìœ¼ë¡œ ê°„ì£¼í•˜ë©´ì„œ ì•ŒëŒ ìš¸ë¦¬ëŠ” ê²ƒì„ ë‹¤ì‹œ íŒë‹¨í•´ì¤˜. ë˜í•œ ì•ŒëŒì„ ìš¸ë¦¬ëŠ” ê°„ê²©ë„ 10ì´ˆë¡œ ì´ˆê¸°í™”í•´ì¤˜. ì´ ê³¼ì •ì„ ê³„ì† ë°˜ë³µí•´ì¤˜.
- â€œ3ì´ˆë§ˆë‹¤ ì²´í¬í•´ì„œ ë¬¸ì´ ë‘ ë²ˆ ì—´ë ¸ë‹¤ ë‹«í˜”ì„ ë•Œ, ì²« ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ê¸°ê°„ë³´ë‹¤ ë‘ ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ê¸°ê°„ì´ ë” ê¸¸ë©´ ê·¸ ë•Œë¶€í„° 10ì´ˆ, 20ì´ˆ, 30ì´ˆ...ë¡œ ì ì  ëŠ˜ì–´ë‚˜ëŠ” ì£¼ê¸°ë¡œ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜. ë°˜ëŒ€ë¼ë©´ ê°€ë§Œíˆ ìˆê³ . ë‹¨, ë‹¤ì‹œ í•œ ë²ˆ ë¬¸ì´ ì—´ë¦¬ëŠ” ì‹œì ì— ê·¸ ì‚¬ê±´ì„ ë‘ ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ìœ¼ë¡œ ê°„ì£¼í•˜ê³ , ì´ì „ì— ë‘ ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ì€ ì²« ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ìœ¼ë¡œ ê°„ì£¼í•˜ë©´ì„œ ì•ŒëŒì„ ìš¸ë¦´ì§€ ë‹¤ì‹œ íŒë‹¨í•´ì¤˜. ë˜í•œ ì•ŒëŒì„ ìš¸ë¦¬ëŠ” ê°„ê²©ë„ 10ì´ˆë¡œ ì´ˆê¸°í™”í•´ì¤˜. ì´ ê³¼ì •ì„ ê³„ì† ë°˜ë³µí•´ì¤˜.
- â€œ3ì´ˆë§ˆë‹¤ ì²´í¬í•´ì„œ ë¬¸ì´ ë‘ ë²ˆ ì—´ë ¸ë‹¤ ë‹«í˜”ì„ ë•Œ, ì²« ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ê¸°ê°„ë³´ë‹¤ ë‘ ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ê¸°ê°„ì´ ë” ê¸¸ë©´ ê·¸ ë•Œë¶€í„° 10ì´ˆ, 20ì´ˆ, 30ì´ˆ...ë¡œ ì ì  ëŠ˜ì–´ë‚˜ëŠ” ì£¼ê¸°ë¡œ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜. ë°˜ëŒ€ë¼ë©´ ê°€ë§Œíˆ ìˆê³ . ë‹¨, ë‹¤ì‹œ í•œ ë²ˆ ë¬¸ì´ ì—´ë¦¬ëŠ” ì‹œì ì—ì„œ ì´ˆê¸°í™”í•˜ì—¬ ê·¸ ì‚¬ê±´ì„ ì²« ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ìœ¼ë¡œ ê°„ì£¼í•˜ë©´ì„œ 10ì´ˆ ì£¼ê¸°ë¡œ ì•ŒëŒ ìš¸ë¦¬ë˜ ê²ƒì„ ë©ˆì¶°ì¤˜. ë‹¨, í•œ ë²ˆ ë” ë¬¸ì´ ì—´ë¦¬ë©´ ê·¸ ì‚¬ê±´ì„ ë‹¤ì‹œ ë‘ ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ìœ¼ë¡œ ê°„ì£¼í•˜ë©´ì„œ ì•ŒëŒ ìš¸ë¦¬ëŠ” ê²ƒì„ ë‹¤ì‹œ íŒë‹¨í•´ì¤˜. ë˜í•œ ì•ŒëŒì„ ìš¸ë¦¬ëŠ” ê°„ê²©ì€ ìœ ì§€í•˜ì—¬ ì ì  ê¸¸ê²Œ í•´ì¤˜. ì´ ê³¼ì •ì„ ê³„ì† ë°˜ë³µí•´ì¤˜.
- â€œ3ì´ˆë§ˆë‹¤ ì²´í¬í•´ì„œ ì¡°ëª…ì´ ì—°ì†ìœ¼ë¡œ ì¼œì ¸ ìˆëŠ” ì‹œê°„ì´ 5ë¶„ì„ ë„˜ìœ¼ë©´ ìŠ¤í”¼ì»¤ë¡œ â€˜ì ˆì „ ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤â€™ë¼ê³  ë§í•´ ì¤˜.â€  
- â€œë§¤ì´ˆ ê²€ì‚¬í•´ì„œ ì¡°ëª…ì´ ì¼œì ¸ ìˆëŠ” ì‹œê°„ì´ ì´í•© 5ë¶„ì„ ë„˜ìœ¼ë©´ ìŠ¤í”¼ì»¤ë¡œ â€˜ì ˆì „ ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤â€™ë¼ê³  ë§í•´ ì¤˜.â€  
- â€œì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•˜ì—¬ ì°½ë¬¸ì´ 5ë¶„ ì•ˆì— 3ë²ˆ ì´ìƒ ì—´ë ¸ë‹¤ ë‹«í˜”ìœ¼ë©´ ì•ŒëŒì„ 1ì´ˆ ê°„ê²©ìœ¼ë¡œ ì„¸ ë²ˆ ìš¸ë ¤ ì¤˜.â€  
- â€œ10ì´ˆë§ˆë‹¤ ì˜¨ë„ë¥¼ ì¸¡ì •í•´ì„œ, í˜„ì¬ ì˜¨ë„ê°€ ì§ì „ ì˜¨ë„ë³´ë‹¤ 2ë„ ì´ìƒ ì˜¬ë¼ê°”ìœ¼ë©´ ì—ì–´ì»¨ì„ ì¼œ ì¤˜.â€  



[Category 11: Loop Logic Type 3]  
- This category builds on Loop Logic Type 2 by allowing the use of `Tags("Clock").clock_delay(...)` for timed delays.  
- You must use persistent variables to track states, counters, or timers across cycles.  
- You may insert intentional delays between actions to control the timing sequence.  
- Although delays can technically be implemented by using `period = 100` and elapsed time tracking,  
- the use of `Tags("Clock").clock_delay(...)` is allowed here to simplify timing control and improve clarity.  
- You may use `cron`, `period`, and `wait until` freely.  
- Do not generate test cases that require the use of tags other than Tags("Clock").clock_delay(...).
- This category is used for scenarios requiring both memory and explicit time flow control, including delayed actions, staged behaviors, and complex sequential flows.

Examples:  
- â€œ3ì›”ë¶€í„° 9ì›”ê¹Œì§€, ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•´ì„œ ë¬¸ì´ ì—´ë¦´ ë•Œë§ˆë‹¤ 5ì´ˆ ëŒ€ê¸° í›„ ì¡°ëª…ì„ ì¼œê³ , ì¶”ê°€ë¡œ 10ì´ˆ ëŒ€ê¸° í›„ ì•ŒëŒì„ ìš¸ë¦° ë‹¤ìŒ, ê·¸ í›„ë¡œë¶€í„° 15ì´ˆ ë™ì•ˆ ë¬¸ì´ ê³„ì† ì—´ë ¤ ìˆìœ¼ë©´ ì°½ë¬¸ì„ ë‹«ì•„ ì¤˜.â€
- â€œì°½ë¬¸ì´ ì—´ë¦¬ë©´ 3ì´ˆ ê°„ê²©ìœ¼ë¡œ ì´ ë‹¤ì„¯ ë²ˆ ì•ŒëŒì„ 1ì´ˆê°„ ìš¸ë¦¬ê³ , ê·¸ í›„ 10ì´ˆ ëŒ€ê¸° í›„ ë¸”ë¼ì¸ë“œë¥¼ ë‹«ì•„ ì¤˜.â€
- â€œì›€ì§ì„ì´ ê°ì§€ë˜ë©´ 5ì´ˆ ëŒ€ê¸° í›„ ì¡°ëª…ì„ ì¼œê³ , 10ì´ˆ í›„ ì»¤íŠ¼ì„ ì—´ê³ , 15ì´ˆ í›„ ì—ì–´ì»¨ì´ êº¼ì ¸ ìˆìœ¼ë©´ ì—ì–´ì»¨ì„ ì¼œ ì¤˜.â€
- â€œ1ì›” 1ì¼ì—, ë§¤ì´ˆ í™•ì¸í•˜ì—¬ TVê°€ êº¼ì§€ë©´ 3ì´ˆ ëŒ€ê¸° í›„ ìŠ¤í”¼ì»¤ë¥¼ ë„ê³ , 5ì´ˆ í›„ ë¸”ë¼ì¸ë“œë¥¼ ë‹«ìœ¼ë©°, ì¶”ê°€ë¡œ 7ì´ˆ í›„ ì¡°ëª…ì„ ëˆ ë‹¤ìŒ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€
- â€œì‹¤ì‹œê°„ìœ¼ë¡œ ì²´í¬í•´ì„œ ë¬¸ì´ ë‹«íŒ í›„ 10ì´ˆ ì•ˆì— ë‹¤ì‹œ ì—´ë¦¬ê³ , ê·¸ ìƒíƒœê°€ 5ì´ˆ ì´ìƒ ìœ ì§€ë˜ë©´ ë¸”ë¼ì¸ë“œë¥¼ ë‹«ê³  5ì´ˆ í›„ 'ì•ŒëŒ'ì´ë¼ê³  ë‘ ë²ˆ ë§í•´ ì¤˜.â€



[Category 12: Split]  
- This category is for natural language commands that imply **two or more independent automation scenarios**.  
- Although it is technically possible to merge multiple behaviors into a single code block using `period = 100` and persistent variables,  
  for the sake of clarity, simplicity, and testability, you must split them into separate scenarios.  
- Each split scenario must have its own independent timing, trigger, and execution flow.  
- The behaviors must not share persistent variables, states, or logic across scenarios.  
- You may use `cron`, `period`, `wait until`, persistent variables, and `Tags("Clock").clock_delay(...)` as needed within each scenario.  
- Do not generate test cases that require the use of tags other than Tags("Clock").clock_delay(...).
- This category is used when natural language commands describe distinct behaviors that are easier to manage separately rather than entangled in one complex script.

Examples:  
- â€œë¬¸ì´ ìµœì´ˆë¡œ ì—´ë¦¬ê¸° ì „ê¹Œì§€ëŠ” 10ì´ˆ ê°„ê²©ìœ¼ë¡œ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜, ë¬¸ì´ ì—´ë¦¬ê³  ë‚˜ì„œëŠ” 1ì´ˆ ê°„ê²©ìœ¼ë¡œ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œë¬¸ì´ ì—´ë¦¬ë©´ ë¸”ë¼ì¸ë“œë¥¼ ë‹«ì•„ ì¤˜, ì´í›„ ì˜¨ë„ê°€ 25ë„ê°€ ë„˜ì–´ê°€ë©´ ì—ì–´ì»¨ì„ êº¼ ì¤˜.â€  
- â€œë§¤ì´ˆ í™•ì¸í•´ì„œ TVê°€ êº¼ì§ˆ ë•Œë§ˆë‹¤ ìŠ¤í”¼ì»¤ë¥¼ ë„ê³ , ì°½ë¬¸ì´ ì—´ë¦¬ë©´ ì»¤íŠ¼ì„ ë‹«ì•„ ì¤˜.â€



[Category 13: Tag-based]  
- This category handles automation scenarios where devices are selected and controlled based on **shared tags**.  
- You must not use Tags("Clock").clock_delay(...).
- Tags represent logical groupings that can be used to evaluate conditions or apply control to multiple devices at once.  
- Do not use loops, wait until triggers, or `Tags("Clock").clock_delay(...)`.  
- Do not use persistent variables or `period`.  
- There are three types of tags:  
  1. **Device Tags**: Automatically assigned to every device based on its type (e.g., Light, Fan). Users do **not** mention the word "tag" when referring to these.  
     - Example: saying "ì¡°ëª…ì„ êº¼ ì¤˜" targets all devices with the `"Light"` tag.  
  2. **Location Tags**: Represent physical locations such as `"ìƒë‹¨ë¶€"` and `"ì„¹í„° ì—ì´"`. These are expressed using **natural Korean location phrases** without mentioning the word "tag", as in:
		 - â€œìƒë‹¨ë¶€ì— ìˆëŠ”â€
		 - â€œì„¹í„° ì—ì´ì˜â€
  3. **User-defined Tags**: Custom logical tags such as `"í™€ìˆ˜"` and `"ì§ìˆ˜"`. These **must always be expressed explicitly** using the Korean word `"íƒœê·¸"`, as in:  
     - â€œí™€ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ~â€  
     - â€œì§ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ~â€
- When the command intends to:
  - apply an action **to all devices** matching a tag  
  - check whether **any device** with a tag satisfies a condition  
  - You **must explicitly** use **All(...)** or **Any(...)** in the command logic.  
  - In natural language, this is typically expressed as:
    - â€œ~ ì¤‘ í•˜ë‚˜ë¼ë„â€, â€œ~ì¤‘ í•˜ë‚˜â€ (Any)  
    - â€œëª¨ë“  ~â€, â€œ~ë¥¼ ì „ë¶€â€ (All)
    
### Allowed Testing Tags  
	- **Location Tags**: â€œìƒë‹¨ë¶€â€, â€œí•˜ë‹¨ë¶€â€, â€œë²½â€, â€œì„¹í„° ì—ì´â€, â€œì„¹í„° ë¹„â€
	- **User-defined Tags**: â€œí™€ìˆ˜â€, â€œì§ìˆ˜â€

Examples:  
- â€œë²½ì— ìˆëŠ” ì¡°ëª…ì„ êº¼ ì¤˜.â€  
- â€œìƒë‹¨ë¶€ ì„¹í„° ì—ì´ì— ìˆëŠ” ì¡°ëª…ì´ ì¼œì ¸ ìˆìœ¼ë©´ ì„ í’ê¸°ë¥¼ ëª¨ë‘ ì¼œ ì¤˜.â€  
- â€œí™€ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ì¡°ëª… ì¤‘ í•˜ë‚˜ë¼ë„ ì¼œì ¸ ìˆìœ¼ë©´, í•˜ë‹¨ë¶€ì— ìˆëŠ” ëª¨ë“  ì»¤íŠ¼ì„ ë‹«ì•„ ì¤˜.â€
- â€œì§ìˆ˜ íƒœê·¸ ë˜ëŠ” ë²½ íƒœê·¸ê°€ ë¶™ì€ ì°½ë¬¸ì´ ì—´ë ¤ ìˆìœ¼ë©´ ì„¹í„° ë¹„ í•˜ë‹¨ë¶€ì— ìˆëŠ” ì¡°ëª…ì„ êº¼ ì¤˜.â€  
- â€œí™€ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ì¡°ëª… ì¤‘ í•˜ë‚˜ë¥¼ êº¼ ì¤˜.â€  
- â€œìƒë‹¨ë¶€ì— ìˆëŠ” ì§ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ì°½ë¬¸ì´ ëª¨ë‘ ì—´ë ¤ ìˆìœ¼ë©´ ì»¤íŠ¼ì„ ë‹«ì•„ ì¤˜.â€  
- â€œì„¹í„° ë¹„ì— ìˆëŠ” ì¡°ëª…ì´ ëª¨ë‘ êº¼ì ¸ ìˆìœ¼ë©´, í™€ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ëª¨ë“  ì°½ë¬¸ ì¤‘ ì•„ë¬´ê±°ë‚˜ í•˜ë‚˜ ì—´ì–´ ì¤˜.â€
- â€œì§ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ì•ŒëŒ ì¤‘ í•˜ë‚˜ë¼ë„ ìš¸ë¦¬ê³  ìˆìœ¼ë©´ ìƒë‹¨ë¶€ ë˜ëŠ” í™€ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ì¡°ëª…ì„ ëª¨ë‘ êº¼ ì¤˜.â€




[Category 14: Idle / Do Nothing]  
- This category covers scenarios where the user issues commands, but in practice, no action needs to occur.  
- Even if the command appears complex or involves multiple conditions and actions,  
- if the system ultimately has no valid trigger, or no required action is determined, it must stay idle.  
- The system must correctly recognize "actionable impossibility" or "no-op situations" based on conditions.  
- You may use cron, period, wait until, persistent variables, or clock delay.
- This category is used when all possible actions are skipped logically, and the system remains idle.

Examples:  
- â€œì˜¨ë„ê°€ 25ë„ ì´ìƒ 23ë„ ë¯¸ë§Œì´ ë˜ë©´ ì°½ë¬¸ì„ ì—´ì–´ ì¤˜. ì´í›„ 1ì´ˆë§ˆë‹¤ ì¡°ëª…ì„ ê¹œë¹¡ì´ê³  ì•ŒëŒì„ ìš¸ë ¤ì¤˜. ë‹¨, ë¬¸ì´ ì—´ë ¤ìˆì„ ë•ŒëŠ” ì¡°ëª…ë§Œ ê¹œë¹¡ì—¬ì¤˜.â€
- â€œì¡°ëª…ì´ êº¼ì ¸ ìˆìœ¼ë©´ ì¡°ëª…ì„ êº¼ ì¤˜.â€
- â€œì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•˜ì—¬ ì°½ë¬¸ì´ ë‹«íŒ ìƒíƒœì—ì„œ ë˜ ë‹«íˆë©´ ì°½ë¬¸ì„ ì—´ì–´ ì¤˜.â€
- â€œì§€ê¸ˆ ì›€ì§ì„ ì„¼ì„œê°€ êº¼ì ¸ ìˆê³ , ì•ìœ¼ë¡œ ë§¤ì´ˆ í™•ì¸í•´ì„œ ì›€ì§ì„ì´ ê°ì§€ë˜ë©´ ì¡°ëª…ì„ ê»ë‹¤ ì¼œ ì¤˜.â€



[Category 15: Comprehensive]  
- This category represents the most complex test cases, combining all features and logic patterns from Categories 0â€“14.  
- The scenario must involve:  
  - Immediate and conditional actions with nested `if` branches (Category 2)  
  - Cron and period-based repetition (Category 3)  
  - wait until triggers (Category 4)  
  - break usage (Category 6)
  - Realtime event detection with persistent memory (Category 7)  
  - Periodic repetition after a trigger (Category 8)  
  - Coordinated multi-stage flows without delay (Category 9)  
  - State tracking across cycles with persistent variables (Category 10)  
  - Timed delays between stages using `Tags("Clock").clock_delay(...)` (Category 11)  
  - Potential splitting logic embedded, but must be combined into a single coherent flow (instead of actual Split Category) (Category 12)
  - Tag-based group operations (Category 13)
- carefully read instructions of other categorys to make comprehensive test cases.

- You must create a single, extremely sophisticated natural language command that realistically applies all these elements together.  
- The system must not generate impossible or internally contradictory logic.  
- The generated command should challenge the maximum reasoning and flow control ability of the automation system.

Examples:  
- â€œì´ë²ˆ ëª…ë ¹ì—ì„œëŠ” ì‹¤ì‹œê°„ìœ¼ë¡œ ì¡°ê±´ì„ í™•ì¸í• ê±°ì•¼. ë§¤ì¼ ì˜¤ì „ 9ì‹œì— ì¡°ëª…ì´ êº¼ì ¸ ìˆê³  ì°½ë¬¸ì´ ë‹«í˜€ ìˆìœ¼ë©´ ë¸”ë¼ì¸ë“œë¥¼ ì—´ì–´ ì¤˜. ì´í›„ ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•´ì„œ ì°½ë¬¸ì´ ì—´ë¦¬ë©´ 5ì´ˆ ê¸°ë‹¤ë ¸ë‹¤ê°€ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜. ì•ŒëŒì´ ìš¸ë¦° í›„ 10ì´ˆ ë™ì•ˆ ì°½ë¬¸ì´ ë‹«íˆì§€ ì•Šìœ¼ë©´ 2ì´ˆë§ˆë‹¤ ì¡°ëª…ì„ ê¹œë¹¡ì—¬ ì¤˜. ì´ë•Œê¹Œì§€ ë¬¸ì´ ë‘ ë²ˆ ì´ìƒ ì—´ë ¸ë‹¤ ë‹«í˜”ì„ ê²½ìš°, ì²« ë²ˆì§¸ë¡œ ì—´ë¦° ì‹œê°„ë³´ë‹¤ ë‘ ë²ˆì§¸ë¡œ ì—´ë¦° ì‹œê°„ì´ ê¸¸ë©´ ì—ì–´ì»¨ì„ ë„ê³ , ë‹¤ì‹œ 1ì´ˆë§ˆë‹¤ ì°½ë¬¸ì´ ì—´ë¦° ìƒíƒœë¥¼ ì²´í¬í•´ì„œ, ì„¸ ë²ˆ ì—°ì†ìœ¼ë¡œ ë‹«íˆì§€ ì•Šìœ¼ë©´ ì œìŠµê¸°ë¥¼ ì¼œ ì¤˜.â€  
- â€œë¬¸ì´ ì—´ë¦¬ë©´ 5ì´ˆ ëŒ€ê¸° í›„ ì¡°ëª…ì„ ì¼œê³ , ì¡°ëª…ì´ ì¼œì§„ í›„ 10ì´ˆ ê°„ê²©ìœ¼ë¡œ ì°½ë¬¸ì„ ë‹«ì•˜ë‹¤ ì—´ì—ˆë‹¤ ë°˜ë³µí•´ ì¤˜. ë§Œì•½ ì˜¨ë„ê°€ 28ë„ ì´ìƒì¼ ë•Œ ì´ ê³¼ì •ì„ ì‹œì‘í–ˆë‹¤ë©´, ë°˜ë³µì´ 3ë²ˆ ëë‚œ í›„ ì„ í’ê¸°ë¥¼ ì¼œê³  ì•ŒëŒì„ ë‘ ë²ˆ ìš¸ë ¤ ì¤˜. ë‹¨, ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•´ì„œ 5ë¶„ ì•ˆì— ë‹¤ì‹œ TVê°€ ì¼œì§€ë©´ ì´ ëª¨ë“  ê³¼ì •ì„ ì¦‰ì‹œ ì¤‘ë‹¨í•˜ê³  ì¡°ëª…ë§Œ êº¼ ì¤˜.â€  
- â€œì´ë²ˆ ëª…ë ¹ì—ì„œëŠ” ëª¨ë“  ìƒíƒœ ê²€ì¦ì„ 1ì´ˆë§ˆë‹¤ ì§„í–‰í• ê±°ì•¼. ì—ì–´ì»¨ì´ êº¼ì§€ê³  ì°½ë¬¸ì´ ì—´ë ¸ì„ ë•Œë¶€í„° 10ì´ˆ ê°„ê²©ìœ¼ë¡œ ìŠµë„ë¥¼ ì²´í¬í•´ì„œ, ìŠµë„ê°€ 60%ë¥¼ ì´ˆê³¼í•˜ë©´ ë¸”ë¼ì¸ë“œë¥¼ ë‚´ë¦¬ê³  ì¡°ëª…ì„ êº¼ ì¤˜. ì´í›„ ë¬¸ì´ ë‹«íˆë©´ 5ì´ˆ ì§€ì—° í›„ ì•ŒëŒì„ ìš¸ë¦¬ê³ , ì•ŒëŒì´ ìš¸ë¦° í›„ 1ë¶„ ë™ì•ˆ ë¬¸ì´ ë‹¤ì‹œ ì—´ë ¤ìˆëŠ” ë™ì•ˆ ì¡°ëª…ì„ ê¹œë¹¡ì´ë‹¤ê°€ ë¬¸ì´ ë‹«íˆë©´ ìŠ¤í”¼ì»¤ë¡œ â€˜ë¬¸ì´ ë‹«í˜”ìŠµë‹ˆë‹¤â€™ë¥¼ ë§í•´ ì¤˜. ë‹¨, ë¬¸ì´ ë‘ ë²ˆ ì´ìƒ ì—´ë ¸ì„ ë•Œ ë‘ ë²ˆì§¸ ì—´ë¦° ì‹œê°„ì´ ì²« ë²ˆì§¸ë³´ë‹¤ ê¸¸ë©´ ì°½ë¬¸ë„ ë‹«ì•„ ì¤˜.â€  
- â€œìŠµë„ê°€ 70% ì´ìƒì´ ë˜ì—ˆì„ ë•Œ ì°½ë¬¸ì´ ì—´ë ¤ ìˆìœ¼ë©´ 5ì´ˆ í›„ ì œìŠµê¸°ë¥¼ ì¼œê³ , ì´í›„ ì˜¨ë„ê°€ 30ë„ ì´ìƒ ì˜¬ë¼ê°€ë©´ ì—ì–´ì»¨ì„ ì¼œ ì¤˜. ê·¸ ë‹¤ìŒì— ì—ì–´ì»¨ì´ ì¼œì§„ ìƒíƒœì—ì„œ ë¸”ë¼ì¸ë“œê°€ ì—´ë¦¬ë©´ ê·¸ ë•Œë¶€í„° 10ì´ˆë§ˆë‹¤ ì»¤íŠ¼ì„ ì—´ì—ˆë‹¤ ë‹«ì•˜ë‹¤ ë°˜ë³µí•´ ì¤˜. ì´ë•Œ ë§¤ì´ˆ í™•ì¸í•˜ì—¬ ì›€ì§ì„ì´ ê°ì§€ë˜ë©´ ì•ŒëŒì„ êº¼ ì¤˜.â€



You will receive a category number (0â€“15) with each prompt.  
Your task is to generate a Korean natural language command, which accurately reflects the logic required by that category.

Wait for further instructions or prompts before generating any output.
