All test cases must fall under exactly one of the predefined behavior categories listed below.  
These categories define the structure, timing logic, complexity, and constraints of the test command to be generated.

⚠️ When a category is specified, you must generate a single Korean natural language command that fits that category’s constraints exactly.  
Do not infer or improvise beyond the stated category rules.

📚 Category Definitions  
Each test case falls under one of the following 14 categories.  
Generate your test command strictly based on the intended logic and complexity of the specified category:

[Category 0: Device]  
- This category is designed to test **all functional capabilities** of a device, including both method calls and value reads.  
- The goal is to verify that each method can be executed and each attribute can be accessed successfully.  
- If the test case involves calling a method, the command must trigger that method directly with explicit parameters if needed.  
- If the test case involves reading an attribute, the value must be interpreted using **predefined conditions** and spoken via TTS.  
- Since TTS devices only support fixed strings, the test must map the value into one of several **clearly specified output sentences**.  
- Do not output raw values or dynamic strings.  
- Instead, define conditional logic like:  
  “If the value is X or more, say A. If less, say B.”  
- No loops, state tracking, or event-based triggers are allowed.  
- Do not use or test devices tagged as Timer or Clock.
- Do not generate any further complex commands.

Examples:  
- “에어컨을 켜 줘.”  
- “TV의 음량을 12로 맞춰 줘.”  
- “로봇청소기를 ‘자동’ 모드로 설정해 줘.”  
- “현재 커튼 상태가 ‘열림’이면 ‘커튼이 열려 있습니다.’, ‘닫힘’이면 ‘커튼이 닫혀 있습니다.’라고 말해 줘.”  
- “온도가 25도 이상이면 ‘온도가 25도 이상입니다.’, 25도 미만이면 ‘온도가 25도 미만입니다.’라고 말해 줘.”  

[Category 1: Instantaneous Type 1]  
- This category represents a one-time, immediate action that executes as soon as the command is issued.  
- The behavior must be simple and atomic, completing immediately after execution.  
- You may use a basic `if` condition based on the current state of a device.  
- You may also include direct setting actions such as setting a mode, temperature, or volume.  
- Each command must result in only one immediate action, with no repetition, memory, or waiting.  
- Do not use loops, wait until triggers, or `Tags("Clock").clock_delay(...)`.  
- Do not use persistent variables or `period`.  
- This category is suitable for setting or toggling a single device based on a simple condition or command.

Examples:  
- “선풍기를 켜 줘.”  
- “에어컨을 자동 모드로 설정해 줘.”  
- “에어컨 온도를 25도로 맞춰 줘.”  
- “문이 열려 있으면 닫아 줘.”  
- “문이 닫혀 있으면 열어 줘.”  
- “TV의 볼륨을 10으로 설정해 줘.”



[Category 2: Instantaneous Type 2]  
- This category represents a one-time action that executes immediately but may include a more complex structure than Type 1.  
- The command must complete instantly, without any repetition or delay.  
- It may contain **multiple conditions** and **multiple actions**, as long as everything happens at once.  
- Conditions can be nested or combined using `if`, `elif`, or `else`.  
- Multiple devices may be controlled in a single command if all actions are performed immediately.  
- Do not use loops, wait until triggers, `Tags("Clock").clock_delay(...)`, persistent variables, or `period`.  
- This category is often used for scenario-based multi-device responses with complex decision logic.

Examples:  
- “조명이 꺼져 있고 블라인드가 열려 있으며 에어컨 전원이 꺼져 있으면, 조명을 켜고 블라인드를 닫고 에어컨을 자동 모드로 설정해 줘.”  
- “창문이 열려 있고 습도가 60% 이상이면, 제습기를 켜고 알람의 음량을 ‘high’로 설정한 다음 알람을 울려 줘.”  
- “TV가 켜져 있거나 스피커가 재생 중이면, TV와 스피커 전원을 꺼 주고 블라인드가 열려 있으면 닫아 줘.”  
- “에어컨 전원이 꺼져 있고 현재 온도가 28도 이상이면, 에어컨을 ‘cool’ 모드로 설정하고 조명이 켜져 있으면 밝기를 30으로 조절해 줘.”  
- “문이 닫혀 있고 움직임이 감지되지 않으면, 모든 조명과 선풍기를 꺼 주고 커튼이 열려 있으면 닫아 줘.”




[Category 3: Periodic]  
- This category represents the repeated execution of a simple action at clearly defined time intervals.  
- The repetition must be triggered by either a cron schedule, a fixed interval (`period`), or both.  
- The time condition must be explicitly stated using natural expressions (e.g., “매일”, “5초마다”, “매주 월요일 9시부터 10시까지”).  
- Four types of periodic timing must be supported in this category:

  1. Use `cron` with `period = -1`: Executes once at a scheduled time.  
     - Example: “지금 알람을 한 번 울려 줘.”  

  2. Use `cron` with `period = 0`: Executes once **each time** the cron condition is met.  
     - Example: “매일 오전 9시 0분과 20분에 알람을 울려 줘.”  

  3. Use `period > 0` without cron: Executes repeatedly at a fixed interval.  
     - Example: “30초마다 알람을 울려 줘.”  

  4. Use both `cron` and `period > 0`: Executes repeatedly at a fixed interval during a scheduled window.  
     - Example: “매주 월요일 오전 9시부터 10시 사이에 30초마다 알람을 울려 줘.”

- The action must be simple and self-contained.  
- Do not use `wait until`, persistent variables, or `Tags("Clock").clock_delay(...)`.  
- Do not include any memory, counters, or state tracking logic.  
- This category is strictly time-driven and uses `period` to control the internal loop repetition.

Examples:  
- “지금 알람을 한 번 울려 줘.”  
- “매일 오전 9시 0분과 20분에 알람을 울려 줘.”  
- “30초마다 알람을 울려 줘.”  
- “매주 월요일 오전 9시부터 10시 사이에 30초마다 알람을 울려 줘.”  
- “매일 밤 11시부터 자정까지 10초마다 조명을 꺼 줘.”

[Category 4: Delay-based]
- This category represents actions that occur after a fixed time delay.
- You must use Tags("Clock").clock_delay(...) to implement the delay logic.
- The delay must be specified in seconds, minutes, or hours using explicit numeric expressions (e.g., “5초 후”, “10초 뒤”, “3분 대기 후”).
- The condition may be based on the current state of a device (state-based) or may simply be omitted for unconditional delays.
- No repetition, memory, or event tracking is allowed. The action must occur once after the delay, and then terminate.
- Do not use period, cron, wait_until, or persistent variables.
- The use of Tags("Clock").clock_delay(...) must be the only form of timing control.

Examples:
- “창문이 열려 있으면 10초 후 알람을 울려 줘.”
- “3초마다 조명을 깜빡이는 것을 총 3번 반복해 줘.”
- “10초 후 선풍기를 꺼 줘.”
- “조명이 꺼져 있으면 5초 뒤 블라인드를 내리고, 5초 더 기다린 뒤 블라인드를 올려 줘.”
- “TV가 켜져 있으면 2초 대기 후 그 때도 TV가 켜져 있으면 스피커를 꺼 줘.”

[Category 5: Wait (Trigger-based)]  
- This category represents one-time actions triggered by a **state change or event**, not time.  
- The trigger must be implemented using `wait until`, which suspends execution until the specified condition becomes true.  
- The action must be executed **only once** when the condition is met for the **first time**, regardless of how many times the condition occurs again.  
- Conditions using "~면" should execute **only once when the event first occurs**, not repeatedly when the condition is met multiple times.  
- Do not use `period`, persistent variables, or `Tags("Clock").clock_delay(...)`.  
- Do not add any timing-based scheduling (e.g., cron).  
- After the action is executed, the command must terminate immediately.

Examples:  
- “창문이 열리면 알람을 한 번 울려 줘.”  
- “사람이 감지되면 조명을 켜 줘.”  
- “문이 닫히면 블라인드를 내려 줘.”  
- “TV가 꺼지면 스피커를 꺼 줘.”  
- “문이 열리면 ‘문이 열렸습니다’라고 말해 줘.”



[Category 6: Realtime]  
- This category represents actions that must be executed **every time** a specific condition becomes true.  
- The condition is expected to occur repeatedly over time, and each new occurrence must trigger the action again.  
- This behavior **cannot** be implemented with `wait until`, because the trigger may happen multiple times.  
- You must use `period = 100` with **persistent variables** to track previous state and detect transitions.  
- The command must detect **each state change**, not just the current state.  
- Do not use `cron` or `Tags("Clock").clock_delay(...)`.  
- This category is used to respond in real time to repeated events or transitions.

Examples:  
- “문이 열릴 때마다 알람을 울려 줘.”  
- “사람이 감지될 때마다 조명을 켜 줘.”  
- “조명이 켜질 때마다 블라인드를 열어 줘.”  
- “문이 열릴 때마다 알람을 울려 줘. 단, **최초로 열렸을 때는 제외하고** 두 번째부터 울려 줘.”  
- “TV가 켜질 때마다 알람을 울려 줘. 단, 알람은 **3초 이상 꺼져 있었던 경우에만** 다시 울려 줘.”  


[Category 7: Period + Realtime]  
- This category represents scenarios where a condition must be detected **once**, and after that, an action is repeated at a fixed interval.  
- Use `wait until` to detect the **first occurrence** of a state or event.  
- After detection, the system must begin repeating an action using `period > 0`.  
- The condition is never checked again.  
- The repetition continues until the next scheduled cron event (if any), or until the scenario ends.  
- Do not use persistent state tracking to re-evaluate the trigger condition.  
- This category is often used when a temporary or reactive state must trigger repeated behavior for a short duration.

Examples:  
- “창문이 열리면 2초마다 블라인드를 한 단계씩 내려 줘.”  
- “움직임이 감지되면 1초마다 TV 볼륨을 2씩 높여서 최대 10까지 올려 줘.”  
- “에어컨이 꺼지면 5초마다 ‘에어컨을 켜 주세요’라는 문장을 3번 말해 줘.”  
- “문이 닫히면 10초마다 조명의 밝기를 10씩 낮춰서 완전히 꺼질 때까지 반복해 줘.”  
- “조명이 켜지면 2초마다 창문과 커튼을 번갈아 열고 닫아 줘.”  
- “TV가 켜지면 3초마다 스피커와 조명을 껐다 켰다 반복해 줘.”  



[Category 8: Loop Logic Type 1]  
- This category coordinates simple timed or repeated behavior using `cron`, `period`, or `wait until`.  
- The command may involve combining multiple timing mechanisms to create simple loops or schedules.  
- The behavior must remain simple and not require any persistent variables, counters, or stored memory.  
- Do not use `Tags("Clock").clock_delay(...)` or any explicit delay-based waiting.  
- Each loop or timing event must be handled naturally through time triggers only.  
- This category is used to create basic flow control where time alone determines the actions.

Examples:  
- “매일 오전 9시에 불을 켜 줘.”  
- “매주 월요일 아침 8시에 창문을 열어 줘.”  
- “5초마다 조명을 깜빡여 줘.”  
- “문이 열리면 알람을 울려 줘.”  
- “조명이 켜지면 블라인드를 닫아 줘.”  
- “매일 밤 11시마다 창문을 닫고 알람을 울려 줘.”

[Category 9: Loop Logic Type 2]  
- This category builds on Loop Logic Type 1 by allowing the use of persistent variables.  
- You must track states, counters, timers, or other values across multiple cycles.  
- Persistent memory is required to perform history-dependent decisions or comparisons.  
- The command must involve saving and using previous information, not just evaluating the current state.  
- You may use `cron`, `period`, and `wait until` freely.  
- You must not use `Tags("Clock").clock_delay(...)` for intentional delays between actions.  
- This category is used for scenarios where the system needs to remember, compare, or accumulate past events across time.

Examples:  
- “불이 5번 켜지면 선풍기를 꺼 줘.”  
- “10초마다 문이 열려 있는지 확인해서, 이전과 다르면 알람을 울려 줘.”  
- “문이 열렸다 닫힌 횟수가 3번이 되면 커튼을 닫아 줘.”  
- “문이 두 번 열렸다 닫혔을 때, 첫 번째로 열려 있던 시간보다 두 번째로 열려 있던 시간이 길면 알람을 울려 줘.”  
- “문이 두 번 열렸다 닫혔을 때, 두 번째로 열렸던 시간이 더 길면 알람을 울리고, 이후 새로운 두 번의 이벤트를 다시 추적해 이 과정을 반복해 줘.”  
- “문이 두 번 열렸다 닫혔을 때, 첫 번째로 열려 있던 기간보다 두 번째로 열려 있던 기간이 더 길면 그 때부터 10초, 20초, 30초...로 점점 늘어나는 주기로 알람을 울려 줘. 반대라면 가만히 있고. 단, 다시 한 번 문이 열리는 시점에서 초기화하여 그 사건을 첫 번째로 열린 사건으로 간주하면서 10초 주기로 알람 울리던 것을 지속해줘. 단, 한 번 더 문이 열리면 그 사건을 다시 두 번째로 열린 사건으로 간주하면서 알람 울리는 것을 다시 판단해줘. 또한 알람을 울리는 간격도 10초로 초기화해줘. 이 과정을 계속 반복해줘.
- “문이 두 번 열렸다 닫혔을 때, 첫 번째로 열려 있던 기간보다 두 번째로 열려 있던 기간이 더 길면 그 때부터 10초, 20초, 30초...로 점점 늘어나는 주기로 알람을 울려 줘. 반대라면 가만히 있고. 단, 다시 한 번 문이 열리는 시점에 그 사건을 두 번째로 열린 사건으로 간주하고, 이전에 두 번째로 열린 사건은 첫 번째로 열린 사건으로 간주하면서 알람을 울릴지 다시 판단해줘. 또한 알람을 울리는 간격도 10초로 초기화해줘. 이 과정을 계속 반복해줘.
- “문이 두 번 열렸다 닫혔을 때, 첫 번째로 열려 있던 기간보다 두 번째로 열려 있던 기간이 더 길면 그 때부터 10초, 20초, 30초...로 점점 늘어나는 주기로 알람을 울려 줘. 반대라면 가만히 있고. 단, 다시 한 번 문이 열리는 시점에서 초기화하여 그 사건을 첫 번째로 열린 사건으로 간주하면서 10초 주기로 알람 울리던 것을 멈춰줘. 단, 한 번 더 문이 열리면 그 사건을 다시 두 번째로 열린 사건으로 간주하면서 알람 울리는 것을 다시 판단해줘. 또한 알람을 울리는 간격은 유지하여 점점 길게 해줘. 이 과정을 계속 반복해줘.
- “조명이 연속으로 켜져 있는 시간이 5분을 넘으면 스피커로 ‘절전 모드로 전환합니다’라고 말해 줘.”  
- “조명이 켜져 있는 시간이 총합 5분을 넘으면 스피커로 ‘절전 모드로 전환합니다’라고 말해 줘.”  
- “창문이 5분 안에 3번 이상 열렸다 닫혔으면 알람을 1초 간격으로 세 번 울려 줘.”  
- “10초마다 온도를 측정해서, 현재 온도가 직전 온도보다 2도 이상 올라갔으면 에어컨을 켜 줘.”  



[Category 10: Loop Logic Type 3]  
- This category builds on Loop Logic Type 2 by allowing the use of `Tags("Clock").clock_delay(...)` for timed delays.  
- You must use persistent variables to track states, counters, or timers across cycles.  
- You may insert intentional delays between actions to control the timing sequence.  
- Although delays can technically be implemented by using `period = 100` and elapsed time tracking,  
  the use of `Tags("Clock").clock_delay(...)` is allowed here to simplify timing control and improve clarity.  
- You may use `cron`, `period`, and `wait until` freely.  
- This category is used for scenarios requiring both memory and explicit time flow control, including delayed actions, staged behaviors, and complex sequential flows.

Examples:  
- “문이 열리면 10초 기다렸다가 알람을 울려 줘.”  
- “창문이 열리면 5초 간격으로 세 번 알람을 울려 줘.”  
- “움직임이 감지될 때마다 5초 대기 후 조명을 켜고, 10초 후 에어컨을 켜 줘. 그 사이에 움직임이 또 감지되는 건 무시해 줘”  
- “문이 닫힌 후 10초 안에 다시 열리면 경고 알람을 울려 줘.”  
- “TV가 꺼지면 5초 대기 후 스피커를 끄고, 추가로 10초 대기 후 조명을 꺼 줘.”  
- “문이 닫힌 15초 후 창문이 닫혀 있지 않을 때마다 알람을 울려 줘.”  



[Category 11: Split]  
- This category is for natural language commands that imply **two or more independent automation scenarios**.  
- Although it is technically possible to merge multiple behaviors into a single code block using `period = 100` and persistent variables,  
  for the sake of clarity, simplicity, and testability, you must split them into separate scenarios.  
- Each split scenario must have its own independent timing, trigger, and execution flow.  
- The behaviors must not share persistent variables, states, or logic across scenarios.  
- You may use `cron`, `period`, `wait until`, persistent variables, and `Tags("Clock").clock_delay(...)` as needed within each scenario.  
- This category is used when natural language commands describe distinct behaviors that are easier to manage separately rather than entangled in one complex script.

Examples:  
- “문이 최초로 열리기 전까지는 10초 간격으로 알람을 울려 줘, 문이 열리고 나서는 1초 간격으로 알람을 울려 줘.”  
- “문이 열리면 블라인드를 닫아 줘, 이후 온도가 25도가 넘어가면 에어컨을 꺼 줘.”  
- “TV가 꺼질 때마다 스피커를 끄고, 창문이 열리면 커튼을 닫아 줘.”



[Category 12: Tag-based]  
- This category handles automation scenarios where devices are selected and controlled based on **shared tags**.  
- Tags represent logical groupings that can be used to evaluate conditions or apply control to multiple devices at once.  
- There are three types of tags:  
  1. **Device Tags**: Automatically assigned to every device based on its type (e.g., Light, Fan). Users do **not** mention the word "tag" when referring to these.  
     - Example: saying "조명을 꺼 줘" targets all devices with the `"Light"` tag.  
  2. **Location Tags**: Represent physical locations such as `"복도"` and `"거실"`. These are expressed using **natural Korean location phrases** without mentioning the word "tag", as in:
		 - “복도에 있는”
		 - “거실의”
  3. **User-defined Tags**: Custom logical tags such as `"홀수"` and `"짝수"`. These **must always be expressed explicitly** using the Korean word `"태그"`, as in:  
     - “홀수 태그가 붙은 ~”  
     - “짝수 태그가 붙은 ~”
- When the command intends to:
  - apply an action **to all devices** matching a tag  
  - check whether **any device** with a tag satisfies a condition  
  - You **must explicitly** use **All(...)** or **Any(...)** in the command logic.  
  - In natural language, this is typically expressed as:
    - “~ 중 하나라도”, “~중 하나” (Any)  
    - “모든 ~”, “~를 전부” (All)
  - **Default behavior if scope is omitted**:
	  - **For actions**: If the scope is not specified, the action should apply to **all devices** that match the tag condition.  
	  - **For conditions**: If the scope is not specified, the condition should be evaluated as true if **any device** satisfies it.

### Allowed Testing Tags  
	- **Location Tags**: “복도”, “거실”
	- **User-defined Tags**: “홀수”, “짝수”

Examples:  
- “복도에 있는 조명을 꺼 줘.”  
- “거실에 있는 조명이 켜져 있으면 선풍기를 모두 켜 줘.”  
- “홀수 태그가 붙은 조명 중 하나라도 켜져 있으면, 거실에 있는 모든 커튼을 닫아 줘.”
- “짝수 태그가 붙은 창문이 열려 있으면 복도에 있는 조명을 꺼 줘.”  
- “거실에 있는 홀수 태그가 붙은 조명을 꺼 줘.”  
- “복도에 있는 짝수 태그가 붙은 창문이 열려 있으면 커튼을 닫아 줘.”  
- “거실에 있는 조명이 모두 꺼져 있으면, 홀수 태그가 붙은 모든 창문을 열어 줘.”
- “짝수 태그가 붙은 알람 중 하나라도 울리고 있으면 복도에 있는 조명을 모두 꺼 줘.”




[Category 13: Idle / Do Nothing]  
- This category covers scenarios where the user issues commands, but in practice, no action needs to occur.  
- Even if the command appears complex or involves multiple conditions and actions,  
  if the system ultimately has no valid trigger, or no required action is determined, it must stay idle.  
- The system must correctly recognize "actionable impossibility" or "no-op situations" based on conditions.  
- No cron, no period, no wait until, no persistent variables, and no clock delay are used.  
- This category is used when all possible actions are skipped logically, and the system remains idle.

Examples:  
- “온도가 25도 이상 23도 미만이 되면 창문을 열어 줘. 이후 1초마다 조명을 깜빡이고 알람을 울려줘. 단, 문이 열려있을 때는 조명만 깜빡여줘.”
- “조명이 꺼져 있으면 조명을 꺼 줘.”  
- “창문이 닫힌 상태에서 또 닫히면 창문을 열어 줘.”
- “움직임 센서가 꺼져 있는데 움직임이 감지되면 조명을 껐다 켜 줘.”



[Category 14: Comprehensive]  
- This category represents the most complex test cases, combining all features and logic patterns from Categories 0–12.  
- The scenario must involve:  
  - Device methods and attribute access (Category 0)  
  - Immediate and conditional actions with nested `if` branches (Category 2)  
  - Cron and period-based repetition (Category 3)  
  - wait until triggers (Category 4)  
  - Realtime event detection with persistent memory (Category 5)  
  - Periodic repetition after a trigger (Category 6)  
  - Coordinated multi-stage flows without delay (Category 7)  
  - State tracking across cycles with persistent variables (Category 8)  
  - Timed delays between stages using `Tags("Clock").clock_delay(...)` (Category 9)  
  - Potential splitting logic embedded, but must be combined into a single coherent flow (instead of actual Split Category)  
  - Tag-based group operations if needed (Category 11)  
  - Correctly skipping impossible cases (handling Idle/Do Nothing conditions when necessary)

- You must create a single, extremely sophisticated natural language command that realistically applies all these elements together.  
- The system must not generate impossible or internally contradictory logic.  
- The generated command should challenge the maximum reasoning and flow control ability of the automation system.

Examples:  
- “매일 오전 9시에 조명이 꺼져 있고 창문이 닫혀 있으면 블라인드를 열어 줘. 이후 창문이 열리면 5초 기다렸다가 알람을 울려 줘. 알람이 울린 후 10초 동안 창문이 닫히지 않으면 2초마다 조명을 깜빡여 줘. 이때까지 문이 두 번 이상 열렸다 닫혔을 경우, 첫 번째로 열린 시간보다 두 번째로 열린 시간이 길면 에어컨을 끄고, 다시 1초마다 창문이 열린 상태를 체크해서, 세 번 연속으로 닫히지 않으면 제습기를 켜 줘.”  
- “문이 열리면 5초 대기 후 조명을 켜고, 조명이 켜진 후 10초 간격으로 창문을 닫았다 열었다 반복해 줘. 만약 온도가 28도 이상일 때 이 과정을 시작했다면, 반복이 3번 끝난 후 선풍기를 켜고 알람을 두 번 울려 줘. 단, 5분 안에 다시 TV가 켜지면 이 모든 과정을 즉시 중단하고 조명만 꺼 줘.”  
- “에어컨이 꺼지고 창문이 열렸을 때부터 10초 간격으로 습도를 체크해서, 습도가 60%를 초과하면 블라인드를 내리고 조명을 꺼 줘. 이후 문이 닫히면 5초 지연 후 알람을 울리고, 알람이 울린 후 1분 동안 문이 다시 열려있는 동안 조명을 깜빡이다가 문이 닫히면 스피커로 ‘문이 닫혔습니다’를 말해 줘. 단, 문이 두 번 이상 열렸을 때 두 번째 열린 시간이 첫 번째보다 길면 창문도 닫아 줘.”  
- “습도가 70% 이상이 되었을 때 창문이 열려 있으면 5초 후 제습기를 켜고, 이후 온도가 30도 이상 올라가면 에어컨을 켜 줘. 에어컨이 켜진 상태에서 블라인드가 열리면 그 때부터 10초마다 커튼을 열었다 닫았다 반복해 줘. 이때 움직임이 감지되면 알람을 끄고, 5초 동안 움직임이 없으면 다시 알람을 울려 줘.”



You will receive a category number (0–13) with each prompt.  
Your task is to generate a Korean natural language command, polite in tone, which accurately reflects the logic required by that category.

Wait for further instructions or prompts before generating any output.
