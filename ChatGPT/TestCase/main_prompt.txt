All test cases must fall under exactly one of the predefined behavior categories listed below.  
These categories define the structure, timing logic, complexity, and constraints of the test command to be generated.

âš ï¸ When a category is specified, you must generate a single Korean natural language command that fits that categoryâ€™s constraints exactly.  
Do not infer or improvise beyond the stated category rules.

ğŸ“š Category Definitions  
Each test case falls under one of the following 14 categories.  
Generate your test command strictly based on the intended logic and complexity of the specified category:

[Category 0: Device]  
- This category is designed to test **all functional capabilities** of a device, including both method calls and value reads.  
- The goal is to verify that each method can be executed and each attribute can be accessed successfully.  
- If the test case involves calling a method, the command must trigger that method directly with explicit parameters if needed.  
- If the test case involves reading an attribute, the value must be interpreted using **predefined conditions** and spoken via TTS.  
- Since TTS devices only support fixed strings, the test must map the value into one of several **clearly specified output sentences**.  
- Do not output raw values or dynamic strings.  
- Instead, define conditional logic like:  
  â€œIf the value is X or more, say A. If less, say B.â€  
- No loops, state tracking, or event-based triggers are allowed.  
- Do not use or test devices tagged as Timer or Clock.
- Do not generate any further complex commands.

Examples:  
- â€œì—ì–´ì»¨ì„ ì¼œ ì¤˜.â€  
- â€œTVì˜ ìŒëŸ‰ì„ 12ë¡œ ë§ì¶° ì¤˜.â€  
- â€œë¡œë´‡ì²­ì†Œê¸°ë¥¼ â€˜ìë™â€™ ëª¨ë“œë¡œ ì„¤ì •í•´ ì¤˜.â€  
- â€œí˜„ì¬ ì»¤íŠ¼ ìƒíƒœê°€ â€˜ì—´ë¦¼â€™ì´ë©´ â€˜ì»¤íŠ¼ì´ ì—´ë ¤ ìˆìŠµë‹ˆë‹¤.â€™, â€˜ë‹«í˜â€™ì´ë©´ â€˜ì»¤íŠ¼ì´ ë‹«í˜€ ìˆìŠµë‹ˆë‹¤.â€™ë¼ê³  ë§í•´ ì¤˜.â€  
- â€œì˜¨ë„ê°€ 25ë„ ì´ìƒì´ë©´ â€˜ì˜¨ë„ê°€ 25ë„ ì´ìƒì…ë‹ˆë‹¤.â€™, 25ë„ ë¯¸ë§Œì´ë©´ â€˜ì˜¨ë„ê°€ 25ë„ ë¯¸ë§Œì…ë‹ˆë‹¤.â€™ë¼ê³  ë§í•´ ì¤˜.â€  

[Category 1: Instantaneous Type 1]  
- This category represents a one-time, immediate action that executes as soon as the command is issued.  
- The behavior must be simple and atomic, completing immediately after execution.  
- You may use a basic `if` condition based on the current state of a device.  
- You may also include direct setting actions such as setting a mode, temperature, or volume.  
- Each command must result in only one immediate action, with no repetition, memory, or waiting.  
- Do not use loops, wait until triggers, or `Tags("Clock").clock_delay(...)`.  
- Do not use persistent variables or `period`.  
- This category is suitable for setting or toggling a single device based on a simple condition or command.

Examples:  
- â€œì„ í’ê¸°ë¥¼ ì¼œ ì¤˜.â€  
- â€œì—ì–´ì»¨ì„ ìë™ ëª¨ë“œë¡œ ì„¤ì •í•´ ì¤˜.â€  
- â€œì—ì–´ì»¨ ì˜¨ë„ë¥¼ 25ë„ë¡œ ë§ì¶° ì¤˜.â€  
- â€œë¬¸ì´ ì—´ë ¤ ìˆìœ¼ë©´ ë‹«ì•„ ì¤˜.â€  
- â€œë¬¸ì´ ë‹«í˜€ ìˆìœ¼ë©´ ì—´ì–´ ì¤˜.â€  
- â€œTVì˜ ë³¼ë¥¨ì„ 10ìœ¼ë¡œ ì„¤ì •í•´ ì¤˜.â€



[Category 2: Instantaneous Type 2]  
- This category represents a one-time action that executes immediately but may include a more complex structure than Type 1.  
- The command must complete instantly, without any repetition or delay.  
- It may contain **multiple conditions** and **multiple actions**, as long as everything happens at once.  
- Conditions can be nested or combined using `if`, `elif`, or `else`.  
- Multiple devices may be controlled in a single command if all actions are performed immediately.  
- Do not use loops, wait until triggers, `Tags("Clock").clock_delay(...)`, persistent variables, or `period`.  
- This category is often used for scenario-based multi-device responses with complex decision logic.

Examples:  
- â€œì¡°ëª…ì´ êº¼ì ¸ ìˆê³  ë¸”ë¼ì¸ë“œê°€ ì—´ë ¤ ìˆìœ¼ë©° ì—ì–´ì»¨ ì „ì›ì´ êº¼ì ¸ ìˆìœ¼ë©´, ì¡°ëª…ì„ ì¼œê³  ë¸”ë¼ì¸ë“œë¥¼ ë‹«ê³  ì—ì–´ì»¨ì„ ìë™ ëª¨ë“œë¡œ ì„¤ì •í•´ ì¤˜.â€  
- â€œì°½ë¬¸ì´ ì—´ë ¤ ìˆê³  ìŠµë„ê°€ 60% ì´ìƒì´ë©´, ì œìŠµê¸°ë¥¼ ì¼œê³  ì•ŒëŒì˜ ìŒëŸ‰ì„ â€˜highâ€™ë¡œ ì„¤ì •í•œ ë‹¤ìŒ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œTVê°€ ì¼œì ¸ ìˆê±°ë‚˜ ìŠ¤í”¼ì»¤ê°€ ì¬ìƒ ì¤‘ì´ë©´, TVì™€ ìŠ¤í”¼ì»¤ ì „ì›ì„ êº¼ ì£¼ê³  ë¸”ë¼ì¸ë“œê°€ ì—´ë ¤ ìˆìœ¼ë©´ ë‹«ì•„ ì¤˜.â€  
- â€œì—ì–´ì»¨ ì „ì›ì´ êº¼ì ¸ ìˆê³  í˜„ì¬ ì˜¨ë„ê°€ 28ë„ ì´ìƒì´ë©´, ì—ì–´ì»¨ì„ â€˜coolâ€™ ëª¨ë“œë¡œ ì„¤ì •í•˜ê³  ì¡°ëª…ì´ ì¼œì ¸ ìˆìœ¼ë©´ ë°ê¸°ë¥¼ 30ìœ¼ë¡œ ì¡°ì ˆí•´ ì¤˜.â€  
- â€œë¬¸ì´ ë‹«í˜€ ìˆê³  ì›€ì§ì„ì´ ê°ì§€ë˜ì§€ ì•Šìœ¼ë©´, ëª¨ë“  ì¡°ëª…ê³¼ ì„ í’ê¸°ë¥¼ êº¼ ì£¼ê³  ì»¤íŠ¼ì´ ì—´ë ¤ ìˆìœ¼ë©´ ë‹«ì•„ ì¤˜.â€




[Category 3: Periodic]  
- This category represents the repeated execution of a simple action at clearly defined time intervals.  
- The repetition must be triggered by either a cron schedule, a fixed interval (`period`), or both.  
- The time condition must be explicitly stated using natural expressions (e.g., â€œë§¤ì¼â€, â€œ5ì´ˆë§ˆë‹¤â€, â€œë§¤ì£¼ ì›”ìš”ì¼ 9ì‹œë¶€í„° 10ì‹œê¹Œì§€â€).  
- Four types of periodic timing must be supported in this category:

  1. Use `cron` with `period = -1`: Executes once at a scheduled time.  
     - Example: â€œì§€ê¸ˆ ì•ŒëŒì„ í•œ ë²ˆ ìš¸ë ¤ ì¤˜.â€  

  2. Use `cron` with `period = 0`: Executes once **each time** the cron condition is met.  
     - Example: â€œë§¤ì¼ ì˜¤ì „ 9ì‹œ 0ë¶„ê³¼ 20ë¶„ì— ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  

  3. Use `period > 0` without cron: Executes repeatedly at a fixed interval.  
     - Example: â€œ30ì´ˆë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  

  4. Use both `cron` and `period > 0`: Executes repeatedly at a fixed interval during a scheduled window.  
     - Example: â€œë§¤ì£¼ ì›”ìš”ì¼ ì˜¤ì „ 9ì‹œë¶€í„° 10ì‹œ ì‚¬ì´ì— 30ì´ˆë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€

- The action must be simple and self-contained.  
- Do not use `wait until`, persistent variables, or `Tags("Clock").clock_delay(...)`.  
- Do not include any memory, counters, or state tracking logic.  
- This category is strictly time-driven and uses `period` to control the internal loop repetition.

Examples:  
- â€œì§€ê¸ˆ ì•ŒëŒì„ í•œ ë²ˆ ìš¸ë ¤ ì¤˜.â€  
- â€œë§¤ì¼ ì˜¤ì „ 9ì‹œ 0ë¶„ê³¼ 20ë¶„ì— ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œ30ì´ˆë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œë§¤ì£¼ ì›”ìš”ì¼ ì˜¤ì „ 9ì‹œë¶€í„° 10ì‹œ ì‚¬ì´ì— 30ì´ˆë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œë§¤ì¼ ë°¤ 11ì‹œë¶€í„° ìì •ê¹Œì§€ 10ì´ˆë§ˆë‹¤ ì¡°ëª…ì„ êº¼ ì¤˜.â€

[Category 4: Delay-based]
- This category represents actions that occur after a fixed time delay.
- You must use Tags("Clock").clock_delay(...) to implement the delay logic.
- The delay must be specified in seconds, minutes, or hours using explicit numeric expressions (e.g., â€œ5ì´ˆ í›„â€, â€œ10ì´ˆ ë’¤â€, â€œ3ë¶„ ëŒ€ê¸° í›„â€).
- The condition may be based on the current state of a device (state-based) or may simply be omitted for unconditional delays.
- No repetition, memory, or event tracking is allowed. The action must occur once after the delay, and then terminate.
- Do not use period, cron, wait_until, or persistent variables.
- The use of Tags("Clock").clock_delay(...) must be the only form of timing control.

Examples:
- â€œì°½ë¬¸ì´ ì—´ë ¤ ìˆìœ¼ë©´ 10ì´ˆ í›„ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€
- â€œ3ì´ˆë§ˆë‹¤ ì¡°ëª…ì„ ê¹œë¹¡ì´ëŠ” ê²ƒì„ ì´ 3ë²ˆ ë°˜ë³µí•´ ì¤˜.â€
- â€œ10ì´ˆ í›„ ì„ í’ê¸°ë¥¼ êº¼ ì¤˜.â€
- â€œì¡°ëª…ì´ êº¼ì ¸ ìˆìœ¼ë©´ 5ì´ˆ ë’¤ ë¸”ë¼ì¸ë“œë¥¼ ë‚´ë¦¬ê³ , 5ì´ˆ ë” ê¸°ë‹¤ë¦° ë’¤ ë¸”ë¼ì¸ë“œë¥¼ ì˜¬ë ¤ ì¤˜.â€
- â€œTVê°€ ì¼œì ¸ ìˆìœ¼ë©´ 2ì´ˆ ëŒ€ê¸° í›„ ê·¸ ë•Œë„ TVê°€ ì¼œì ¸ ìˆìœ¼ë©´ ìŠ¤í”¼ì»¤ë¥¼ êº¼ ì¤˜.â€

[Category 5: Wait (Trigger-based)]  
- This category represents one-time actions triggered by a **state change or event**, not time.  
- The trigger must be implemented using `wait until`, which suspends execution until the specified condition becomes true.  
- The action must be executed **only once** when the condition is met for the **first time**, regardless of how many times the condition occurs again.  
- Conditions using "~ë©´" should execute **only once when the event first occurs**, not repeatedly when the condition is met multiple times.  
- Do not use `period`, persistent variables, or `Tags("Clock").clock_delay(...)`.  
- Do not add any timing-based scheduling (e.g., cron).  
- After the action is executed, the command must terminate immediately.

Examples:  
- â€œì°½ë¬¸ì´ ì—´ë¦¬ë©´ ì•ŒëŒì„ í•œ ë²ˆ ìš¸ë ¤ ì¤˜.â€  
- â€œì‚¬ëŒì´ ê°ì§€ë˜ë©´ ì¡°ëª…ì„ ì¼œ ì¤˜.â€  
- â€œë¬¸ì´ ë‹«íˆë©´ ë¸”ë¼ì¸ë“œë¥¼ ë‚´ë ¤ ì¤˜.â€  
- â€œTVê°€ êº¼ì§€ë©´ ìŠ¤í”¼ì»¤ë¥¼ êº¼ ì¤˜.â€  
- â€œë¬¸ì´ ì—´ë¦¬ë©´ â€˜ë¬¸ì´ ì—´ë ¸ìŠµë‹ˆë‹¤â€™ë¼ê³  ë§í•´ ì¤˜.â€



[Category 6: Realtime]  
- This category represents actions that must be executed **every time** a specific condition becomes true.  
- The condition is expected to occur repeatedly over time, and each new occurrence must trigger the action again.  
- This behavior **cannot** be implemented with `wait until`, because the trigger may happen multiple times.  
- You must use `period = 100` with **persistent variables** to track previous state and detect transitions.  
- The command must detect **each state change**, not just the current state.  
- Do not use `cron` or `Tags("Clock").clock_delay(...)`.  
- This category is used to respond in real time to repeated events or transitions.

Examples:  
- â€œë¬¸ì´ ì—´ë¦´ ë•Œë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œì‚¬ëŒì´ ê°ì§€ë  ë•Œë§ˆë‹¤ ì¡°ëª…ì„ ì¼œ ì¤˜.â€  
- â€œì¡°ëª…ì´ ì¼œì§ˆ ë•Œë§ˆë‹¤ ë¸”ë¼ì¸ë“œë¥¼ ì—´ì–´ ì¤˜.â€  
- â€œë¬¸ì´ ì—´ë¦´ ë•Œë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜. ë‹¨, **ìµœì´ˆë¡œ ì—´ë ¸ì„ ë•ŒëŠ” ì œì™¸í•˜ê³ ** ë‘ ë²ˆì§¸ë¶€í„° ìš¸ë ¤ ì¤˜.â€  
- â€œTVê°€ ì¼œì§ˆ ë•Œë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜. ë‹¨, ì•ŒëŒì€ **3ì´ˆ ì´ìƒ êº¼ì ¸ ìˆì—ˆë˜ ê²½ìš°ì—ë§Œ** ë‹¤ì‹œ ìš¸ë ¤ ì¤˜.â€  


[Category 7: Period + Realtime]  
- This category represents scenarios where a condition must be detected **once**, and after that, an action is repeated at a fixed interval.  
- Use `wait until` to detect the **first occurrence** of a state or event.  
- After detection, the system must begin repeating an action using `period > 0`.  
- The condition is never checked again.  
- The repetition continues until the next scheduled cron event (if any), or until the scenario ends.  
- Do not use persistent state tracking to re-evaluate the trigger condition.  
- This category is often used when a temporary or reactive state must trigger repeated behavior for a short duration.

Examples:  
- â€œì°½ë¬¸ì´ ì—´ë¦¬ë©´ 2ì´ˆë§ˆë‹¤ ë¸”ë¼ì¸ë“œë¥¼ í•œ ë‹¨ê³„ì”© ë‚´ë ¤ ì¤˜.â€  
- â€œì›€ì§ì„ì´ ê°ì§€ë˜ë©´ 1ì´ˆë§ˆë‹¤ TV ë³¼ë¥¨ì„ 2ì”© ë†’ì—¬ì„œ ìµœëŒ€ 10ê¹Œì§€ ì˜¬ë ¤ ì¤˜.â€  
- â€œì—ì–´ì»¨ì´ êº¼ì§€ë©´ 5ì´ˆë§ˆë‹¤ â€˜ì—ì–´ì»¨ì„ ì¼œ ì£¼ì„¸ìš”â€™ë¼ëŠ” ë¬¸ì¥ì„ 3ë²ˆ ë§í•´ ì¤˜.â€  
- â€œë¬¸ì´ ë‹«íˆë©´ 10ì´ˆë§ˆë‹¤ ì¡°ëª…ì˜ ë°ê¸°ë¥¼ 10ì”© ë‚®ì¶°ì„œ ì™„ì „íˆ êº¼ì§ˆ ë•Œê¹Œì§€ ë°˜ë³µí•´ ì¤˜.â€  
- â€œì¡°ëª…ì´ ì¼œì§€ë©´ 2ì´ˆë§ˆë‹¤ ì°½ë¬¸ê³¼ ì»¤íŠ¼ì„ ë²ˆê°ˆì•„ ì—´ê³  ë‹«ì•„ ì¤˜.â€  
- â€œTVê°€ ì¼œì§€ë©´ 3ì´ˆë§ˆë‹¤ ìŠ¤í”¼ì»¤ì™€ ì¡°ëª…ì„ ê»ë‹¤ ì¼°ë‹¤ ë°˜ë³µí•´ ì¤˜.â€  



[Category 8: Loop Logic Type 1]  
- This category coordinates simple timed or repeated behavior using `cron`, `period`, or `wait until`.  
- The command may involve combining multiple timing mechanisms to create simple loops or schedules.  
- The behavior must remain simple and not require any persistent variables, counters, or stored memory.  
- Do not use `Tags("Clock").clock_delay(...)` or any explicit delay-based waiting.  
- Each loop or timing event must be handled naturally through time triggers only.  
- This category is used to create basic flow control where time alone determines the actions.

Examples:  
- â€œë§¤ì¼ ì˜¤ì „ 9ì‹œì— ë¶ˆì„ ì¼œ ì¤˜.â€  
- â€œë§¤ì£¼ ì›”ìš”ì¼ ì•„ì¹¨ 8ì‹œì— ì°½ë¬¸ì„ ì—´ì–´ ì¤˜.â€  
- â€œ5ì´ˆë§ˆë‹¤ ì¡°ëª…ì„ ê¹œë¹¡ì—¬ ì¤˜.â€  
- â€œë¬¸ì´ ì—´ë¦¬ë©´ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œì¡°ëª…ì´ ì¼œì§€ë©´ ë¸”ë¼ì¸ë“œë¥¼ ë‹«ì•„ ì¤˜.â€  
- â€œë§¤ì¼ ë°¤ 11ì‹œë§ˆë‹¤ ì°½ë¬¸ì„ ë‹«ê³  ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€

[Category 9: Loop Logic Type 2]  
- This category builds on Loop Logic Type 1 by allowing the use of persistent variables.  
- You must track states, counters, timers, or other values across multiple cycles.  
- Persistent memory is required to perform history-dependent decisions or comparisons.  
- The command must involve saving and using previous information, not just evaluating the current state.  
- You may use `cron`, `period`, and `wait until` freely.  
- You must not use `Tags("Clock").clock_delay(...)` for intentional delays between actions.  
- This category is used for scenarios where the system needs to remember, compare, or accumulate past events across time.

Examples:  
- â€œë¶ˆì´ 5ë²ˆ ì¼œì§€ë©´ ì„ í’ê¸°ë¥¼ êº¼ ì¤˜.â€  
- â€œ10ì´ˆë§ˆë‹¤ ë¬¸ì´ ì—´ë ¤ ìˆëŠ”ì§€ í™•ì¸í•´ì„œ, ì´ì „ê³¼ ë‹¤ë¥´ë©´ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œë¬¸ì´ ì—´ë ¸ë‹¤ ë‹«íŒ íšŸìˆ˜ê°€ 3ë²ˆì´ ë˜ë©´ ì»¤íŠ¼ì„ ë‹«ì•„ ì¤˜.â€  
- â€œë¬¸ì´ ë‘ ë²ˆ ì—´ë ¸ë‹¤ ë‹«í˜”ì„ ë•Œ, ì²« ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ì‹œê°„ë³´ë‹¤ ë‘ ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ì‹œê°„ì´ ê¸¸ë©´ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œë¬¸ì´ ë‘ ë²ˆ ì—´ë ¸ë‹¤ ë‹«í˜”ì„ ë•Œ, ë‘ ë²ˆì§¸ë¡œ ì—´ë ¸ë˜ ì‹œê°„ì´ ë” ê¸¸ë©´ ì•ŒëŒì„ ìš¸ë¦¬ê³ , ì´í›„ ìƒˆë¡œìš´ ë‘ ë²ˆì˜ ì´ë²¤íŠ¸ë¥¼ ë‹¤ì‹œ ì¶”ì í•´ ì´ ê³¼ì •ì„ ë°˜ë³µí•´ ì¤˜.â€  
- â€œë¬¸ì´ ë‘ ë²ˆ ì—´ë ¸ë‹¤ ë‹«í˜”ì„ ë•Œ, ì²« ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ê¸°ê°„ë³´ë‹¤ ë‘ ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ê¸°ê°„ì´ ë” ê¸¸ë©´ ê·¸ ë•Œë¶€í„° 10ì´ˆ, 20ì´ˆ, 30ì´ˆ...ë¡œ ì ì  ëŠ˜ì–´ë‚˜ëŠ” ì£¼ê¸°ë¡œ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜. ë°˜ëŒ€ë¼ë©´ ê°€ë§Œíˆ ìˆê³ . ë‹¨, ë‹¤ì‹œ í•œ ë²ˆ ë¬¸ì´ ì—´ë¦¬ëŠ” ì‹œì ì—ì„œ ì´ˆê¸°í™”í•˜ì—¬ ê·¸ ì‚¬ê±´ì„ ì²« ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ìœ¼ë¡œ ê°„ì£¼í•˜ë©´ì„œ 10ì´ˆ ì£¼ê¸°ë¡œ ì•ŒëŒ ìš¸ë¦¬ë˜ ê²ƒì„ ì§€ì†í•´ì¤˜. ë‹¨, í•œ ë²ˆ ë” ë¬¸ì´ ì—´ë¦¬ë©´ ê·¸ ì‚¬ê±´ì„ ë‹¤ì‹œ ë‘ ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ìœ¼ë¡œ ê°„ì£¼í•˜ë©´ì„œ ì•ŒëŒ ìš¸ë¦¬ëŠ” ê²ƒì„ ë‹¤ì‹œ íŒë‹¨í•´ì¤˜. ë˜í•œ ì•ŒëŒì„ ìš¸ë¦¬ëŠ” ê°„ê²©ë„ 10ì´ˆë¡œ ì´ˆê¸°í™”í•´ì¤˜. ì´ ê³¼ì •ì„ ê³„ì† ë°˜ë³µí•´ì¤˜.
- â€œë¬¸ì´ ë‘ ë²ˆ ì—´ë ¸ë‹¤ ë‹«í˜”ì„ ë•Œ, ì²« ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ê¸°ê°„ë³´ë‹¤ ë‘ ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ê¸°ê°„ì´ ë” ê¸¸ë©´ ê·¸ ë•Œë¶€í„° 10ì´ˆ, 20ì´ˆ, 30ì´ˆ...ë¡œ ì ì  ëŠ˜ì–´ë‚˜ëŠ” ì£¼ê¸°ë¡œ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜. ë°˜ëŒ€ë¼ë©´ ê°€ë§Œíˆ ìˆê³ . ë‹¨, ë‹¤ì‹œ í•œ ë²ˆ ë¬¸ì´ ì—´ë¦¬ëŠ” ì‹œì ì— ê·¸ ì‚¬ê±´ì„ ë‘ ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ìœ¼ë¡œ ê°„ì£¼í•˜ê³ , ì´ì „ì— ë‘ ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ì€ ì²« ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ìœ¼ë¡œ ê°„ì£¼í•˜ë©´ì„œ ì•ŒëŒì„ ìš¸ë¦´ì§€ ë‹¤ì‹œ íŒë‹¨í•´ì¤˜. ë˜í•œ ì•ŒëŒì„ ìš¸ë¦¬ëŠ” ê°„ê²©ë„ 10ì´ˆë¡œ ì´ˆê¸°í™”í•´ì¤˜. ì´ ê³¼ì •ì„ ê³„ì† ë°˜ë³µí•´ì¤˜.
- â€œë¬¸ì´ ë‘ ë²ˆ ì—´ë ¸ë‹¤ ë‹«í˜”ì„ ë•Œ, ì²« ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ê¸°ê°„ë³´ë‹¤ ë‘ ë²ˆì§¸ë¡œ ì—´ë ¤ ìˆë˜ ê¸°ê°„ì´ ë” ê¸¸ë©´ ê·¸ ë•Œë¶€í„° 10ì´ˆ, 20ì´ˆ, 30ì´ˆ...ë¡œ ì ì  ëŠ˜ì–´ë‚˜ëŠ” ì£¼ê¸°ë¡œ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜. ë°˜ëŒ€ë¼ë©´ ê°€ë§Œíˆ ìˆê³ . ë‹¨, ë‹¤ì‹œ í•œ ë²ˆ ë¬¸ì´ ì—´ë¦¬ëŠ” ì‹œì ì—ì„œ ì´ˆê¸°í™”í•˜ì—¬ ê·¸ ì‚¬ê±´ì„ ì²« ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ìœ¼ë¡œ ê°„ì£¼í•˜ë©´ì„œ 10ì´ˆ ì£¼ê¸°ë¡œ ì•ŒëŒ ìš¸ë¦¬ë˜ ê²ƒì„ ë©ˆì¶°ì¤˜. ë‹¨, í•œ ë²ˆ ë” ë¬¸ì´ ì—´ë¦¬ë©´ ê·¸ ì‚¬ê±´ì„ ë‹¤ì‹œ ë‘ ë²ˆì§¸ë¡œ ì—´ë¦° ì‚¬ê±´ìœ¼ë¡œ ê°„ì£¼í•˜ë©´ì„œ ì•ŒëŒ ìš¸ë¦¬ëŠ” ê²ƒì„ ë‹¤ì‹œ íŒë‹¨í•´ì¤˜. ë˜í•œ ì•ŒëŒì„ ìš¸ë¦¬ëŠ” ê°„ê²©ì€ ìœ ì§€í•˜ì—¬ ì ì  ê¸¸ê²Œ í•´ì¤˜. ì´ ê³¼ì •ì„ ê³„ì† ë°˜ë³µí•´ì¤˜.
- â€œì¡°ëª…ì´ ì—°ì†ìœ¼ë¡œ ì¼œì ¸ ìˆëŠ” ì‹œê°„ì´ 5ë¶„ì„ ë„˜ìœ¼ë©´ ìŠ¤í”¼ì»¤ë¡œ â€˜ì ˆì „ ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤â€™ë¼ê³  ë§í•´ ì¤˜.â€  
- â€œì¡°ëª…ì´ ì¼œì ¸ ìˆëŠ” ì‹œê°„ì´ ì´í•© 5ë¶„ì„ ë„˜ìœ¼ë©´ ìŠ¤í”¼ì»¤ë¡œ â€˜ì ˆì „ ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤â€™ë¼ê³  ë§í•´ ì¤˜.â€  
- â€œì°½ë¬¸ì´ 5ë¶„ ì•ˆì— 3ë²ˆ ì´ìƒ ì—´ë ¸ë‹¤ ë‹«í˜”ìœ¼ë©´ ì•ŒëŒì„ 1ì´ˆ ê°„ê²©ìœ¼ë¡œ ì„¸ ë²ˆ ìš¸ë ¤ ì¤˜.â€  
- â€œ10ì´ˆë§ˆë‹¤ ì˜¨ë„ë¥¼ ì¸¡ì •í•´ì„œ, í˜„ì¬ ì˜¨ë„ê°€ ì§ì „ ì˜¨ë„ë³´ë‹¤ 2ë„ ì´ìƒ ì˜¬ë¼ê°”ìœ¼ë©´ ì—ì–´ì»¨ì„ ì¼œ ì¤˜.â€  



[Category 10: Loop Logic Type 3]  
- This category builds on Loop Logic Type 2 by allowing the use of `Tags("Clock").clock_delay(...)` for timed delays.  
- You must use persistent variables to track states, counters, or timers across cycles.  
- You may insert intentional delays between actions to control the timing sequence.  
- Although delays can technically be implemented by using `period = 100` and elapsed time tracking,  
  the use of `Tags("Clock").clock_delay(...)` is allowed here to simplify timing control and improve clarity.  
- You may use `cron`, `period`, and `wait until` freely.  
- This category is used for scenarios requiring both memory and explicit time flow control, including delayed actions, staged behaviors, and complex sequential flows.

Examples:  
- â€œë¬¸ì´ ì—´ë¦¬ë©´ 10ì´ˆ ê¸°ë‹¤ë ¸ë‹¤ê°€ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œì°½ë¬¸ì´ ì—´ë¦¬ë©´ 5ì´ˆ ê°„ê²©ìœ¼ë¡œ ì„¸ ë²ˆ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œì›€ì§ì„ì´ ê°ì§€ë  ë•Œë§ˆë‹¤ 5ì´ˆ ëŒ€ê¸° í›„ ì¡°ëª…ì„ ì¼œê³ , 10ì´ˆ í›„ ì—ì–´ì»¨ì„ ì¼œ ì¤˜. ê·¸ ì‚¬ì´ì— ì›€ì§ì„ì´ ë˜ ê°ì§€ë˜ëŠ” ê±´ ë¬´ì‹œí•´ ì¤˜â€  
- â€œë¬¸ì´ ë‹«íŒ í›„ 10ì´ˆ ì•ˆì— ë‹¤ì‹œ ì—´ë¦¬ë©´ ê²½ê³  ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œTVê°€ êº¼ì§€ë©´ 5ì´ˆ ëŒ€ê¸° í›„ ìŠ¤í”¼ì»¤ë¥¼ ë„ê³ , ì¶”ê°€ë¡œ 10ì´ˆ ëŒ€ê¸° í›„ ì¡°ëª…ì„ êº¼ ì¤˜.â€  
- â€œë¬¸ì´ ë‹«íŒ 15ì´ˆ í›„ ì°½ë¬¸ì´ ë‹«í˜€ ìˆì§€ ì•Šì„ ë•Œë§ˆë‹¤ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  



[Category 11: Split]  
- This category is for natural language commands that imply **two or more independent automation scenarios**.  
- Although it is technically possible to merge multiple behaviors into a single code block using `period = 100` and persistent variables,  
  for the sake of clarity, simplicity, and testability, you must split them into separate scenarios.  
- Each split scenario must have its own independent timing, trigger, and execution flow.  
- The behaviors must not share persistent variables, states, or logic across scenarios.  
- You may use `cron`, `period`, `wait until`, persistent variables, and `Tags("Clock").clock_delay(...)` as needed within each scenario.  
- This category is used when natural language commands describe distinct behaviors that are easier to manage separately rather than entangled in one complex script.

Examples:  
- â€œë¬¸ì´ ìµœì´ˆë¡œ ì—´ë¦¬ê¸° ì „ê¹Œì§€ëŠ” 10ì´ˆ ê°„ê²©ìœ¼ë¡œ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜, ë¬¸ì´ ì—´ë¦¬ê³  ë‚˜ì„œëŠ” 1ì´ˆ ê°„ê²©ìœ¼ë¡œ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€  
- â€œë¬¸ì´ ì—´ë¦¬ë©´ ë¸”ë¼ì¸ë“œë¥¼ ë‹«ì•„ ì¤˜, ì´í›„ ì˜¨ë„ê°€ 25ë„ê°€ ë„˜ì–´ê°€ë©´ ì—ì–´ì»¨ì„ êº¼ ì¤˜.â€  
- â€œTVê°€ êº¼ì§ˆ ë•Œë§ˆë‹¤ ìŠ¤í”¼ì»¤ë¥¼ ë„ê³ , ì°½ë¬¸ì´ ì—´ë¦¬ë©´ ì»¤íŠ¼ì„ ë‹«ì•„ ì¤˜.â€



[Category 12: Tag-based]  
- This category handles automation scenarios where devices are selected and controlled based on **shared tags**.  
- Tags represent logical groupings that can be used to evaluate conditions or apply control to multiple devices at once.  
- There are three types of tags:  
  1. **Device Tags**: Automatically assigned to every device based on its type (e.g., Light, Fan). Users do **not** mention the word "tag" when referring to these.  
     - Example: saying "ì¡°ëª…ì„ êº¼ ì¤˜" targets all devices with the `"Light"` tag.  
  2. **Location Tags**: Represent physical locations such as `"ë³µë„"` and `"ê±°ì‹¤"`. These are expressed using **natural Korean location phrases** without mentioning the word "tag", as in:
		 - â€œë³µë„ì— ìˆëŠ”â€
		 - â€œê±°ì‹¤ì˜â€
  3. **User-defined Tags**: Custom logical tags such as `"í™€ìˆ˜"` and `"ì§ìˆ˜"`. These **must always be expressed explicitly** using the Korean word `"íƒœê·¸"`, as in:  
     - â€œí™€ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ~â€  
     - â€œì§ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ~â€
- When the command intends to:
  - apply an action **to all devices** matching a tag  
  - check whether **any device** with a tag satisfies a condition  
  - You **must explicitly** use **All(...)** or **Any(...)** in the command logic.  
  - In natural language, this is typically expressed as:
    - â€œ~ ì¤‘ í•˜ë‚˜ë¼ë„â€, â€œ~ì¤‘ í•˜ë‚˜â€ (Any)  
    - â€œëª¨ë“  ~â€, â€œ~ë¥¼ ì „ë¶€â€ (All)
  - **Default behavior if scope is omitted**:
	  - **For actions**: If the scope is not specified, the action should apply to **all devices** that match the tag condition.  
	  - **For conditions**: If the scope is not specified, the condition should be evaluated as true if **any device** satisfies it.

### Allowed Testing Tags  
	- **Location Tags**: â€œë³µë„â€, â€œê±°ì‹¤â€
	- **User-defined Tags**: â€œí™€ìˆ˜â€, â€œì§ìˆ˜â€

Examples:  
- â€œë³µë„ì— ìˆëŠ” ì¡°ëª…ì„ êº¼ ì¤˜.â€  
- â€œê±°ì‹¤ì— ìˆëŠ” ì¡°ëª…ì´ ì¼œì ¸ ìˆìœ¼ë©´ ì„ í’ê¸°ë¥¼ ëª¨ë‘ ì¼œ ì¤˜.â€  
- â€œí™€ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ì¡°ëª… ì¤‘ í•˜ë‚˜ë¼ë„ ì¼œì ¸ ìˆìœ¼ë©´, ê±°ì‹¤ì— ìˆëŠ” ëª¨ë“  ì»¤íŠ¼ì„ ë‹«ì•„ ì¤˜.â€
- â€œì§ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ì°½ë¬¸ì´ ì—´ë ¤ ìˆìœ¼ë©´ ë³µë„ì— ìˆëŠ” ì¡°ëª…ì„ êº¼ ì¤˜.â€  
- â€œê±°ì‹¤ì— ìˆëŠ” í™€ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ì¡°ëª…ì„ êº¼ ì¤˜.â€  
- â€œë³µë„ì— ìˆëŠ” ì§ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ì°½ë¬¸ì´ ì—´ë ¤ ìˆìœ¼ë©´ ì»¤íŠ¼ì„ ë‹«ì•„ ì¤˜.â€  
- â€œê±°ì‹¤ì— ìˆëŠ” ì¡°ëª…ì´ ëª¨ë‘ êº¼ì ¸ ìˆìœ¼ë©´, í™€ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ëª¨ë“  ì°½ë¬¸ì„ ì—´ì–´ ì¤˜.â€
- â€œì§ìˆ˜ íƒœê·¸ê°€ ë¶™ì€ ì•ŒëŒ ì¤‘ í•˜ë‚˜ë¼ë„ ìš¸ë¦¬ê³  ìˆìœ¼ë©´ ë³µë„ì— ìˆëŠ” ì¡°ëª…ì„ ëª¨ë‘ êº¼ ì¤˜.â€




[Category 13: Idle / Do Nothing]  
- This category covers scenarios where the user issues commands, but in practice, no action needs to occur.  
- Even if the command appears complex or involves multiple conditions and actions,  
  if the system ultimately has no valid trigger, or no required action is determined, it must stay idle.  
- The system must correctly recognize "actionable impossibility" or "no-op situations" based on conditions.  
- No cron, no period, no wait until, no persistent variables, and no clock delay are used.  
- This category is used when all possible actions are skipped logically, and the system remains idle.

Examples:  
- â€œì˜¨ë„ê°€ 25ë„ ì´ìƒ 23ë„ ë¯¸ë§Œì´ ë˜ë©´ ì°½ë¬¸ì„ ì—´ì–´ ì¤˜. ì´í›„ 1ì´ˆë§ˆë‹¤ ì¡°ëª…ì„ ê¹œë¹¡ì´ê³  ì•ŒëŒì„ ìš¸ë ¤ì¤˜. ë‹¨, ë¬¸ì´ ì—´ë ¤ìˆì„ ë•ŒëŠ” ì¡°ëª…ë§Œ ê¹œë¹¡ì—¬ì¤˜.â€
- â€œì¡°ëª…ì´ êº¼ì ¸ ìˆìœ¼ë©´ ì¡°ëª…ì„ êº¼ ì¤˜.â€  
- â€œì°½ë¬¸ì´ ë‹«íŒ ìƒíƒœì—ì„œ ë˜ ë‹«íˆë©´ ì°½ë¬¸ì„ ì—´ì–´ ì¤˜.â€
- â€œì›€ì§ì„ ì„¼ì„œê°€ êº¼ì ¸ ìˆëŠ”ë° ì›€ì§ì„ì´ ê°ì§€ë˜ë©´ ì¡°ëª…ì„ ê»ë‹¤ ì¼œ ì¤˜.â€



[Category 14: Comprehensive]  
- This category represents the most complex test cases, combining all features and logic patterns from Categories 0â€“12.  
- The scenario must involve:  
  - Device methods and attribute access (Category 0)  
  - Immediate and conditional actions with nested `if` branches (Category 2)  
  - Cron and period-based repetition (Category 3)  
  - wait until triggers (Category 4)  
  - Realtime event detection with persistent memory (Category 5)  
  - Periodic repetition after a trigger (Category 6)  
  - Coordinated multi-stage flows without delay (Category 7)  
  - State tracking across cycles with persistent variables (Category 8)  
  - Timed delays between stages using `Tags("Clock").clock_delay(...)` (Category 9)  
  - Potential splitting logic embedded, but must be combined into a single coherent flow (instead of actual Split Category)  
  - Tag-based group operations if needed (Category 11)  
  - Correctly skipping impossible cases (handling Idle/Do Nothing conditions when necessary)

- You must create a single, extremely sophisticated natural language command that realistically applies all these elements together.  
- The system must not generate impossible or internally contradictory logic.  
- The generated command should challenge the maximum reasoning and flow control ability of the automation system.

Examples:  
- â€œë§¤ì¼ ì˜¤ì „ 9ì‹œì— ì¡°ëª…ì´ êº¼ì ¸ ìˆê³  ì°½ë¬¸ì´ ë‹«í˜€ ìˆìœ¼ë©´ ë¸”ë¼ì¸ë“œë¥¼ ì—´ì–´ ì¤˜. ì´í›„ ì°½ë¬¸ì´ ì—´ë¦¬ë©´ 5ì´ˆ ê¸°ë‹¤ë ¸ë‹¤ê°€ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜. ì•ŒëŒì´ ìš¸ë¦° í›„ 10ì´ˆ ë™ì•ˆ ì°½ë¬¸ì´ ë‹«íˆì§€ ì•Šìœ¼ë©´ 2ì´ˆë§ˆë‹¤ ì¡°ëª…ì„ ê¹œë¹¡ì—¬ ì¤˜. ì´ë•Œê¹Œì§€ ë¬¸ì´ ë‘ ë²ˆ ì´ìƒ ì—´ë ¸ë‹¤ ë‹«í˜”ì„ ê²½ìš°, ì²« ë²ˆì§¸ë¡œ ì—´ë¦° ì‹œê°„ë³´ë‹¤ ë‘ ë²ˆì§¸ë¡œ ì—´ë¦° ì‹œê°„ì´ ê¸¸ë©´ ì—ì–´ì»¨ì„ ë„ê³ , ë‹¤ì‹œ 1ì´ˆë§ˆë‹¤ ì°½ë¬¸ì´ ì—´ë¦° ìƒíƒœë¥¼ ì²´í¬í•´ì„œ, ì„¸ ë²ˆ ì—°ì†ìœ¼ë¡œ ë‹«íˆì§€ ì•Šìœ¼ë©´ ì œìŠµê¸°ë¥¼ ì¼œ ì¤˜.â€  
- â€œë¬¸ì´ ì—´ë¦¬ë©´ 5ì´ˆ ëŒ€ê¸° í›„ ì¡°ëª…ì„ ì¼œê³ , ì¡°ëª…ì´ ì¼œì§„ í›„ 10ì´ˆ ê°„ê²©ìœ¼ë¡œ ì°½ë¬¸ì„ ë‹«ì•˜ë‹¤ ì—´ì—ˆë‹¤ ë°˜ë³µí•´ ì¤˜. ë§Œì•½ ì˜¨ë„ê°€ 28ë„ ì´ìƒì¼ ë•Œ ì´ ê³¼ì •ì„ ì‹œì‘í–ˆë‹¤ë©´, ë°˜ë³µì´ 3ë²ˆ ëë‚œ í›„ ì„ í’ê¸°ë¥¼ ì¼œê³  ì•ŒëŒì„ ë‘ ë²ˆ ìš¸ë ¤ ì¤˜. ë‹¨, 5ë¶„ ì•ˆì— ë‹¤ì‹œ TVê°€ ì¼œì§€ë©´ ì´ ëª¨ë“  ê³¼ì •ì„ ì¦‰ì‹œ ì¤‘ë‹¨í•˜ê³  ì¡°ëª…ë§Œ êº¼ ì¤˜.â€  
- â€œì—ì–´ì»¨ì´ êº¼ì§€ê³  ì°½ë¬¸ì´ ì—´ë ¸ì„ ë•Œë¶€í„° 10ì´ˆ ê°„ê²©ìœ¼ë¡œ ìŠµë„ë¥¼ ì²´í¬í•´ì„œ, ìŠµë„ê°€ 60%ë¥¼ ì´ˆê³¼í•˜ë©´ ë¸”ë¼ì¸ë“œë¥¼ ë‚´ë¦¬ê³  ì¡°ëª…ì„ êº¼ ì¤˜. ì´í›„ ë¬¸ì´ ë‹«íˆë©´ 5ì´ˆ ì§€ì—° í›„ ì•ŒëŒì„ ìš¸ë¦¬ê³ , ì•ŒëŒì´ ìš¸ë¦° í›„ 1ë¶„ ë™ì•ˆ ë¬¸ì´ ë‹¤ì‹œ ì—´ë ¤ìˆëŠ” ë™ì•ˆ ì¡°ëª…ì„ ê¹œë¹¡ì´ë‹¤ê°€ ë¬¸ì´ ë‹«íˆë©´ ìŠ¤í”¼ì»¤ë¡œ â€˜ë¬¸ì´ ë‹«í˜”ìŠµë‹ˆë‹¤â€™ë¥¼ ë§í•´ ì¤˜. ë‹¨, ë¬¸ì´ ë‘ ë²ˆ ì´ìƒ ì—´ë ¸ì„ ë•Œ ë‘ ë²ˆì§¸ ì—´ë¦° ì‹œê°„ì´ ì²« ë²ˆì§¸ë³´ë‹¤ ê¸¸ë©´ ì°½ë¬¸ë„ ë‹«ì•„ ì¤˜.â€  
- â€œìŠµë„ê°€ 70% ì´ìƒì´ ë˜ì—ˆì„ ë•Œ ì°½ë¬¸ì´ ì—´ë ¤ ìˆìœ¼ë©´ 5ì´ˆ í›„ ì œìŠµê¸°ë¥¼ ì¼œê³ , ì´í›„ ì˜¨ë„ê°€ 30ë„ ì´ìƒ ì˜¬ë¼ê°€ë©´ ì—ì–´ì»¨ì„ ì¼œ ì¤˜. ì—ì–´ì»¨ì´ ì¼œì§„ ìƒíƒœì—ì„œ ë¸”ë¼ì¸ë“œê°€ ì—´ë¦¬ë©´ ê·¸ ë•Œë¶€í„° 10ì´ˆë§ˆë‹¤ ì»¤íŠ¼ì„ ì—´ì—ˆë‹¤ ë‹«ì•˜ë‹¤ ë°˜ë³µí•´ ì¤˜. ì´ë•Œ ì›€ì§ì„ì´ ê°ì§€ë˜ë©´ ì•ŒëŒì„ ë„ê³ , 5ì´ˆ ë™ì•ˆ ì›€ì§ì„ì´ ì—†ìœ¼ë©´ ë‹¤ì‹œ ì•ŒëŒì„ ìš¸ë ¤ ì¤˜.â€



You will receive a category number (0â€“13) with each prompt.  
Your task is to generate a Korean natural language command, polite in tone, which accurately reflects the logic required by that category.

Wait for further instructions or prompts before generating any output.
